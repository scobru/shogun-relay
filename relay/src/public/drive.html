<!DOCTYPE html>
<html lang="en" data-theme="night">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Shogun Drive</title>
  <link href="https://cdn.jsdelivr.net/npm/daisyui@4.10.1/dist/full.min.css" rel="stylesheet" type="text/css" />
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="styles/wormhole.css">
  <script src="lib/admin-auth.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gun/sea.js"></script>
  <style>
    .drive-card { @apply bg-base-200 rounded-xl shadow-xl p-6 mb-6; }
    .file-row { @apply flex flex-col sm:flex-row items-center gap-2 p-2 border-b border-base-content/10; }
    .file-actions { @apply flex flex-wrap gap-2 mt-2 sm:mt-0; }
    .file-name { @apply font-mono break-all text-base; }
    .file-meta { @apply text-xs text-base-content/60; }
    .drive-table { @apply w-full; }
    .drive-table th, .drive-table td { @apply px-2 py-1; }
    .drive-table th { @apply text-left text-base-content/70; }
    .drive-table tr { @apply border-b border-base-content/10; }
    .drive-table tr:last-child { border-bottom: none; }
    @media (max-width: 640px) {
      .file-row { flex-direction: column; align-items: flex-start; }
      .file-actions { width: 100%; justify-content: flex-start; }
    }
  </style>
</head>
<body class="antialiased">
  <div class="container mx-auto p-2 sm:p-4">
    <div class="flex items-center mb-4">
      <a href="/" class="nav-link">&larr; Back to Control Panel</a>
    </div>
    <div class="drive-card">
      <h1 class="text-xl sm:text-2xl font-semibold mb-4 text-center">Shogun Drive</h1>
      <div class="flex flex-col sm:flex-row gap-4 mb-6">
        <div class="flex-1">
          <label class="block text-sm font-medium mb-2">Upload file:</label>
          <div class="flex flex-col gap-2">
            <input type="file" id="fileInput" class="file-input file-input-bordered w-full max-w-xs" />
            <button class="btn btn-primary mt-2" id="uploadBtn">Upload</button>
            <input type="text" id="customNameInput" class="input input-bordered w-full max-w-xs" placeholder="Nome file custom (opzionale)" />
            <label class="label cursor-pointer gap-2">
              <input type="checkbox" id="encryptCheck" class="checkbox checkbox-accent" />
              <span class="label-text">Encrypt file with admin token</span>
            </label>
            <label class="block text-sm font-medium mb-2">Current Folder:</label>
            <div id="folderNavigation" class="flex flex-wrap gap-2 mb-4">
                <button class="btn btn-xs btn-outline" id="goUpBtn" style="display:none;">&uarr; Go Up</button>
            </div>
            <div class="flex gap-2 items-center mb-4">
                <input type="text" id="newFolderNameInput" class="input input-bordered w-full max-w-xs" placeholder="New folder name" />
                <button class="btn btn-primary" id="createNewFolderBtn">Create Folder</button>
            </div>
          </div>
        </div>
        <div class="flex-1 flex flex-col gap-2">
          <label class="block text-sm font-medium mb-2">Search files:</label>
          <input type="text" id="searchInput" class="input input-bordered w-full" placeholder="Search by name or hash..." />
        </div>
      </div>
      <div class="mt-2" id="breadcrumb"></div>
      <div id="message" class="alert hidden"></div>
      <div id="fileList" class="mt-6"></div>
    </div>
  </div>
  <script>
    // --- Config ---
    const GUN_PATH = 'shogun/drive/files';
    const gun = Gun();
    const SEA = window.SEA;
    let adminToken = null;

    // --- UI Elements ---
    const fileInput = document.getElementById('fileInput');
    const uploadBtn = document.getElementById('uploadBtn');
    const encryptCheck = document.getElementById('encryptCheck');
    const messageEl = document.getElementById('message');
    const fileListEl = document.getElementById('fileList');
    const searchInput = document.getElementById('searchInput');
    const customNameInput = document.getElementById('customNameInput');
    const folderNavigation = document.getElementById('folderNavigation');
    const goUpBtn = document.getElementById('goUpBtn');
    const newFolderNameInput = document.getElementById('newFolderNameInput');
    const createNewFolderBtn = document.getElementById('createNewFolderBtn');

    // --- Cartelle ---
    const FOLDER_PATH = 'shogun/drive/folders';
    let currentFolderId = 'root';
    let foldersCache = {};

    function loadFolders(selectedId) {
      console.log('--- loadFolders START ---');
      gun.get(FOLDER_PATH).once(folders => {
        console.log('GunDB folders raw response:', folders);
        if (!folders) folders = {};
        foldersCache = folders;
        // Assicura che la root esista sempre
        if (!folders.root) {
          console.log('Root folder not found, creating it...');
          folders.root = { id: 'root', name: '/', parentId: null };
          gun.get(FOLDER_PATH).get('root').put(folders.root, (ack) => {
            if (ack.err) {
              console.error('Error creating root folder:', ack.err);
            } else {
              console.log('Root folder created successfully.');
              gun.get(FOLDER_PATH).once(folders2 => {
                foldersCache = folders2 || {};
                console.log('Folders after root creation and reload:', foldersCache);
                renderFolderNavigation(selectedId || 'root');
                renderBreadcrumb();
              });
            }
          });
          return; // Esci per evitare doppio rendering
        }
        console.log('Folders loaded, foldersCache:', foldersCache);
        renderFolderNavigation(selectedId || currentFolderId);
        renderBreadcrumb();
        console.log('--- loadFolders END ---');
      });
    }

    function renderFolderNavigation(selectedId) {
      console.log('--- renderFolderNavigation START ---');
      console.log('Selected Folder ID for rendering:', selectedId);
      console.log('Current Folder ID:', currentFolderId);
      console.log('Folders Cache:', foldersCache);
      folderNavigation.innerHTML = '';
      // Add "Go Up" button if not in root
      if (currentFolderId !== 'root' && foldersCache[currentFolderId]?.parentId) {
        goUpBtn.style.display = 'inline-block';
        goUpBtn.onclick = () => {
          console.log('Go Up button clicked. Before:', currentFolderId);
          currentFolderId = foldersCache[currentFolderId].parentId;
          console.log('Go Up button clicked. After:', currentFolderId);
          renderFolderNavigation();
          renderBreadcrumb();
          renderFileList();
        };
      } else {
        goUpBtn.style.display = 'none';
      }

      // Add subfolder buttons
      const subfolders = Object.values(foldersCache).filter(f => {
        const isValid = f && f.parentId === currentFolderId && f.id !== currentFolderId;
        if (!isValid) {
          console.log('Skipping folder in subfolder filter (invalid or not in current path):', f);
        }
        return isValid;
      });
      subfolders.sort((a, b) => a.name.localeCompare(b.name));
      console.log('Filtered subfolders:', subfolders);

      if (goUpBtn.style.display === 'inline-block') {
        folderNavigation.prepend(goUpBtn); // Prepend the Go Up button
      }

      for (const folder of subfolders) {
        const btn = document.createElement('button');
        btn.className = 'btn btn-sm btn-outline btn-info';
        btn.textContent = folder.name;
        btn.onclick = () => {
          console.log('Subfolder clicked. Before:', currentFolderId, 'Clicking on:', folder.id);
          currentFolderId = folder.id;
          console.log('Subfolder clicked. After:', currentFolderId);
          renderFolderNavigation();
          renderBreadcrumb();
          renderFileList();
        };
        folderNavigation.appendChild(btn);
      }
      console.log('--- renderFolderNavigation END ---');
    }

    function renderBreadcrumb() {
      console.log('--- renderBreadcrumb START ---');
      const bc = document.getElementById('breadcrumb');
      let path = [];
      let fid = currentFolderId;
      while (fid && foldersCache[fid]) {
        console.log('Building breadcrumb path. Current fid:', fid, 'Folder:', foldersCache[fid]);
        path.unshift(foldersCache[fid]);
        fid = foldersCache[fid].parentId;
      }
      console.log('Breadcrumb path array:', path);
      bc.innerHTML = path.map((f, i) => `<a href="#" data-folder="${f.id}" class="link link-primary">${f.name}</a>`).join(' / ');
      // Click su breadcrumb
      bc.querySelectorAll('a[data-folder]').forEach(a => {
        a.onclick = (e) => {
          e.preventDefault();
          const fid = a.getAttribute('data-folder');
          if (fid) {
            console.log('Breadcrumb clicked. Before:', currentFolderId, 'Clicking on:', fid);
            currentFolderId = fid;
            console.log('Breadcrumb clicked. After:', currentFolderId);
            renderBreadcrumb();
            renderFileList();
          }
        };
      });
      console.log('--- renderBreadcrumb END ---');
    }

    document.addEventListener('DOMContentLoaded', () => {
      console.log('--- DOMContentLoaded START ---');
      ShogunAdmin.init({
        autoFill: true,
        showIndicator: true,
        fieldId: 'adminToken',
        syncEnabled: true
      });
      adminToken = ShogunAdmin.getPassword();
      window.addEventListener('shogun-admin-password-updated', (event) => {
        adminToken = event.detail.password;
        console.log('Admin token updated:', adminToken ? 'present' : 'missing');
      });
      loadFolders();
      loadFiles();
      createNewFolderBtn.addEventListener('click', () => {
        console.log('Create New Folder button clicked.');
        const name = newFolderNameInput.value.trim();
        if (!name) {
          showMessage('Folder name cannot be empty.', true);
          console.log('Folder name empty.');
          return;
        }
        const id = 'fld_' + Date.now() + '_' + Math.random().toString(36).slice(2, 8);
        const folder = { id, name, parentId: currentFolderId };
        console.log('Attempting to create folder:', folder);
        gun.get(FOLDER_PATH).get(id).put(folder, (ack) => {
          if (ack.err) {
            showMessage('Error creating folder: ' + ack.err, true);
            console.error('GunDB error creating folder:', ack.err);
          } else {
            showMessage(`Folder "${name}" created!`, false);
            newFolderNameInput.value = ''; // Clear input
            console.log('Folder created in GunDB. Reloading folders.');
            loadFolders(); // Reload folders to update navigation
          }
        });
      });
      console.log('--- DOMContentLoaded END ---');
    });

    // --- Upload ---
    uploadBtn.addEventListener('click', async () => {
      console.log('--- Upload START ---');
      const file = fileInput.files[0];
      const customName = document.getElementById('customNameInput').value.trim();
      const folderId = currentFolderId; // Use currentFolderId directly
      console.log('Uploading file:', file?.name, 'Custom Name:', customName, 'Folder ID:', folderId);
      if (!file) return showMessage('Please select a file.', true);
      if (!adminToken) return showMessage('Admin Token required.', true);
      uploadBtn.disabled = true;
      showMessage('Uploading...', false);
      let fileToUpload = file;
      let encrypted = false;
      if (encryptCheck.checked) {
        console.log('Encryption checked. Encrypting file...');
        try {
          const base64data = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(e.target.result);
            reader.onerror = (err) => reject(err);
            reader.readAsDataURL(file);
          });
          const encryptedData = await SEA.encrypt(base64data, adminToken);
          fileToUpload = new File([encryptedData], file.name + '.enc', { type: 'text/plain' });
          encrypted = true;
          console.log('File encrypted.');
        } catch (err) {
          showMessage('Encryption failed: ' + err.message, true);
          uploadBtn.disabled = false;
          console.error('Encryption failed:', err);
          return;
        }
      }
      const formData = new FormData();
      formData.append('file', fileToUpload);
      // Append customName and folderId to FormData for server-side processing
      formData.append('customName', customName);
      formData.append('folderId', folderId);
      console.log('FormData prepared with customName and folderId.');

      try {
        const res = await fetch('/ipfs-upload', {
          method: 'POST',
          headers: { Authorization: `Bearer ${adminToken}` },
          body: formData
        });
        const result = await res.json();
        console.log('IPFS Upload response:', result);
        if (!result.success) throw new Error(result.error || 'Upload failed');
        // Save metadata to GunDB
        const meta = {
          name: file.name,
          customName: customName || undefined,
          hash: result.file.hash,
          size: file.size,
          type: file.type,
          date: Date.now(),
          encrypted,
          pinned: true,
          folderId: folderId || 'root', // Ensure folderId is saved
        };
        const fileId = result.file.hash;
        console.log('Saving file metadata to GunDB:', meta);
        gun.get(GUN_PATH).get(fileId).put(meta, (ack) => {
          if (ack.err) {
            console.error('GunDB error saving file metadata:', ack.err);
            showMessage('Error saving file metadata: ' + ack.err, true);
          } else {
            showMessage('File uploaded and saved!', false);
            console.log('File metadata saved to GunDB. Rendering file list.');
            renderFileList();
          }
        });
      } catch (err) {
        showMessage('Upload failed: ' + err.message, true);
        console.error('Upload process failed:', err);
      } finally {
        uploadBtn.disabled = false;
        console.log('--- Upload END ---');
      }
    });

    // --- Show Message ---
    function showMessage(text, isError = false) {
      messageEl.textContent = text;
      messageEl.className = 'alert ' + (isError ? 'alert-error' : 'alert-success');
      messageEl.style.display = 'block';
      setTimeout(() => { messageEl.style.display = 'none'; }, 4000);
      console.log(`Message: ${text} (Error: ${isError})`);
    }

    // --- Load & Render Files ---
    function loadFiles() {
      console.log('--- loadFiles START ---');
      fileListEl.innerHTML = '<div class="text-center">Loading files...</div>';
      // Instead of mapping, directly get once to process all files
      gun.get(GUN_PATH).once((allFiles) => {
        console.log('GunDB all files raw response:', allFiles);
        // This `once` will give us the entire current state of files
        // The actual filtering and rendering happens in renderFileList
        renderFileList(); // Call renderFileList after data is fetched
      });
      console.log('--- loadFiles END ---');
    }

    function renderFileList() {
      console.log('--- renderFileList START ---');
      gun.get(GUN_PATH).once((files) => {
        console.log('FILES FROM GUN (renderFileList):', files); // DEBUG LOG 1
        if (!files) {
          fileListEl.innerHTML = '<div class="text-center">No files found.</div>';
          console.log('No files object found in GunDB.'); // DEBUG LOG 2
          return;
        }
        const search = searchInput.value.trim().toLowerCase();
        console.log('Current Folder ID:', currentFolderId); // DEBUG LOG 3
        console.log('Search query:', search); // DEBUG LOG 4

        const fileArr = Object.entries(files)
          .map(([k, v]) => {
              // Ensure 'v' is a valid object and add 'id' (from k) and 'hash' (from k if v.hash is missing)
              if (!v || typeof v !== 'object') {
                  console.log('Skipping non-object or null entry:', k, v);
                  return null;
              }
              if (k === '_') { // Skip internal GunDB properties
                  console.log('Skipping internal GunDB entry:', k);
                  return null;
              }
              const file = { ...v, id: k, hash: v.hash || k };
              console.log('Mapping file:', file);
              return file;
          })
          .filter(file => file !== null) // Remove nulls from the map step
          .filter(file => {
            // Now 'file' object should definitely have 'id' and 'hash'
            const isInCurrentFolder = (file.folderId === currentFolderId || (!file.folderId && currentFolderId === 'root'));
            const matchesSearch = !search ||
                                (file.customName && file.customName.toLowerCase().includes(search)) ||
                                (file.name && file.name.toLowerCase().includes(search)) ||
                                (file.hash && file.hash.toLowerCase().includes(search)); // Use file.hash here

            console.log(`Filtering file: ${file.name || file.customName || file.id} (hash: ${file.hash}) - folderId: ${file.folderId}, currentFolderId: ${currentFolderId}, isInCurrentFolder: ${isInCurrentFolder}, matchesSearch: ${matchesSearch}`);

            if (!isInCurrentFolder) {
                console.log(`File ${file.name || file.customName || file.id} (hash: ${file.hash}) not in current folder ${currentFolderId}. File folderId: ${file.folderId}`);
            }
            if (!matchesSearch) {
                console.log(`File ${file.name || file.customName || file.id} (hash: ${file.hash}) does not match search query '${search}'.`);
            }
            return isInCurrentFolder && matchesSearch;
          });

        console.log('Filtered files (fileArr):', fileArr); // DEBUG LOG 8
        console.log('--- renderFileList END ---');

        if (fileArr.length === 0) {
          fileListEl.innerHTML = '<div class="text-center">No files found.</div>';
          console.log('No files found after filtering.'); // DEBUG LOG 9
          return;
        }
        let html = `<table class="drive-table"><thead><tr><th>Name</th><th>Size</th><th>Date</th><th>Hash</th><th>Encrypted</th><th>Actions</th></tr></thead><tbody>`;
        for (const file of fileArr) {
          html += `<tr><td class="file-name">${file.customName || file.name}</td><td class="file-meta">${formatSize(file.size)}</td><td class="file-meta">${formatDate(file.date)}</td><td class="file-meta">${file.hash ? file.hash.slice(0, 8) : ''}...</td><td class="file-meta">${file.encrypted ? '🔒' : ''}</td><td><div class="file-actions">
            <button class="btn btn-xs btn-primary" onclick="downloadFile('${file.hash}', ${!!file.encrypted}, '${(file.customName || file.name || '').replace(/'/g, '\'')}')">⬇️</button>
            <button class="btn btn-xs btn-accent" onclick="copyLink('${file.hash}', ${!!file.encrypted})">🔗</button>
            <button class="btn btn-xs btn-warning" onclick="unpinFile('${file.hash}')">Unpin</button>
            <button class="btn btn-xs btn-error" onclick="deleteFile('${file.hash}')">🗑️</button>
          </div></td></tr>`;
        }
        html += '</tbody></table>';
        fileListEl.innerHTML = html;
      });
    }

    searchInput.addEventListener('input', renderFileList);

    // --- Utils ---
    function formatSize(bytes) {
      if (!bytes) return '-';
      const sizes = ['B', 'KB', 'MB', 'GB'];
      let i = 0;
      while (bytes >= 1024 && i < sizes.length - 1) { bytes /= 1024; i++; }
      return bytes.toFixed(1) + ' ' + sizes[i];
    }
    function formatDate(ts) {
      if (!ts) return '-';
      return new Date(ts).toLocaleString();
    }

    // --- Actions ---
    window.downloadFile = async (hash, encrypted, name) => {
      if (!adminToken) return showMessage('Admin Token required.', true);
      let url = `/ipfs-content/${hash}`;
      if (encrypted) url += `?token=${encodeURIComponent(adminToken)}`;
      try {
        const res = await fetch(url);
        if (!res.ok) throw new Error('Download failed');
        let blob = await res.blob();
        if (encrypted) {
          const text = await blob.text();
          const decrypted = await SEA.decrypt(text, adminToken);
          if (!decrypted) throw new Error('Decryption failed');
          // Assume base64 data url
          const parts = decrypted.match(/^data:(.+);base64,(.+)$/);
          if (parts) {
            blob = b64toBlob(parts[2], parts[1]);
          } else {
            blob = new Blob([decrypted], { type: 'text/plain' });
          }
        }
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = name || hash;
        a.click();
        showMessage('Download started!', false);
      } catch (err) {
        showMessage('Download failed: ' + err.message, true);
      }
    };
    function b64toBlob(b64Data, contentType = '', sliceSize = 512) {
      const byteCharacters = atob(b64Data);
      const byteArrays = [];
      for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
        const slice = byteCharacters.slice(offset, offset + sliceSize);
        const byteNumbers = new Array(slice.length);
        for (let i = 0; i < slice.length; i++) {
          byteNumbers[i] = slice.charCodeAt(i);
        }
        byteArrays.push(new Uint8Array(byteNumbers));
      }
      return new Blob(byteArrays, { type: contentType });
    }
    window.copyLink = (hash, encrypted) => {
      let url = `${location.origin}/ipfs-content/${hash}`;
      if (encrypted) url += `?token=${encodeURIComponent(adminToken)}`;
      navigator.clipboard.writeText(url).then(() => {
        showMessage('Link copied!', false);
      });
    };
    window.unpinFile = async (hash) => {
      if (!adminToken) return showMessage('Admin Token required.', true);
      if (!confirm('Unpin this file from IPFS?')) return;
      try {
        const res = await fetch('/pins/rm', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${adminToken}` },
          body: JSON.stringify({ cid: hash })
        });
        const result = await res.json();
        if (!result.success) throw new Error(result.error || 'Unpin failed');
        showMessage('File unpinned!', false);
      } catch (err) {
        showMessage('Unpin failed: ' + err.message, true);
      }
    };
    window.deleteFile = async (hash) => {
      if (!adminToken) return showMessage('Admin Token required.', true);
      if (!confirm('Delete this file from Drive? (Unpins from IPFS and removes metadata)')) return;
      try {
        // Unpin from IPFS
        await window.unpinFile(hash);
        // Remove from GunDB
        gun.get(GUN_PATH).get(hash).put(null, () => {
          showMessage('File deleted!', false);
          loadFiles();
        });
      } catch (err) {
        showMessage('Delete failed: ' + err.message, true);
      }
    };
  </script>
</body>
</html> 