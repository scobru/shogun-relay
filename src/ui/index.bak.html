<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Shogun Relay Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
    <style>
      :root {
        --primary-color: #2dd4bf;
        --primary-dark: #14b8a6;
        --secondary-color: #8b5cf6;
        --secondary-dark: #7c3aed;
        --success-color: #4ade80;
        --error-color: #f43f5e;
        --warning-color: #facc15;
        --info-color: #38bdf8;
        --dark-bg: #121212;
        --dark-surface: #1e1e1e;
        --dark-card: #252525;
        --text-color: #e2e8f0;
        --text-secondary: #94a3b8;
        --border-color: #2e2e2e;
        --nav-bg: #181818;
        --header-bg: #0f172a;
      }

      * {
        box-sizing: border-box;
      }

      body {
        font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        margin: 0;
        padding: 0;
        line-height: 1.6;
        color: var(--text-color);
        background-color: var(--dark-bg);
        transition: all 0.3s ease;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
      }

      header {
        background-color: var(--header-bg);
        color: white;
        padding: 20px 0;
        margin-bottom: 20px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      header h1 {
        margin: 0;
        padding: 0 20px;
        font-size: 24px;
        font-weight: 600;
        letter-spacing: 0.5px;
      }

      .navbar {
        background-color: var(--nav-bg);
        padding: 12px 24px;
        margin-bottom: 20px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-radius: 8px;
        border: 1px solid var(--border-color);
      }

      .nav-links {
        display: flex;
        gap: 24px;
      }

      .nav-links a {
        color: var(--text-color);
        text-decoration: none;
        font-weight: 500;
        position: relative;
        padding: 5px 0;
        transition: all 0.3s ease;
      }

      .nav-links a:hover {
        color: var(--primary-color);
      }

      .nav-links a:after {
        content: '';
        position: absolute;
        width: 0;
        height: 2px;
        bottom: 0;
        left: 0;
        background-color: var(--primary-color);
        transition: width 0.3s ease;
      }

      .nav-links a:hover:after {
        width: 100%;
      }

      .nav-links a.active {
        color: var(--primary-color);
      }

      .nav-links a.active:after {
        width: 100%;
      }

      .logout-btn {
        background: rgba(244, 63, 94, 0.1);
        border: 1px solid rgba(244, 63, 94, 0.3);
        color: var(--error-color);
        cursor: pointer;
        font-weight: 500;
        padding: 6px 14px;
        border-radius: 6px;
        transition: all 0.3s ease;
      }

      .logout-btn:hover {
        background: rgba(244, 63, 94, 0.2);
      }

      h1, h2, h3, h4 {
        color: var(--primary-color);
        font-weight: 600;
      }

      .card {
        background: var(--dark-card);
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 24px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        border: 1px solid var(--border-color);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .card:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
      }

      .card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 18px;
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 12px;
      }

      .card-title {
        margin: 0;
        font-size: 18px;
        letter-spacing: 0.5px;
        font-weight: 600;
      }

      .card-actions {
        display: flex;
        gap: 10px;
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: 24px;
        margin-bottom: 24px;
      }

      .stat-card {
        background: var(--dark-card);
        border-radius: 10px;
        padding: 20px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        text-align: center;
        border: 1px solid var(--border-color);
        transition: all 0.3s ease;
      }

      .stat-card:hover {
        transform: translateY(-3px);
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
        border-color: rgba(45, 212, 191, 0.3);
      }

      .stat-value {
        font-size: 28px;
        font-weight: bold;
        color: var(--primary-color);
        margin: 12px 0;
        text-shadow: 0 0 10px rgba(45, 212, 191, 0.3);
      }

      .stat-label {
        color: var(--text-secondary);
        font-size: 14px;
        font-weight: 500;
        letter-spacing: 0.5px;
      }

      textarea,
      input[type="text"],
      input[type="file"],
      input[type="number"],
      input[type="password"] {
        width: 100%;
        padding: 12px;
        font-size: 16px;
        border-radius: 8px;
        border: 1px solid var(--border-color);
        margin-bottom: 12px;
        background-color: var(--dark-surface);
        color: var(--text-color);
        transition: all 0.3s ease;
      }
      
      input[type="text"]:focus,
      input[type="password"]:focus,
      input[type="number"]:focus,
      textarea:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 2px rgba(45, 212, 191, 0.2);
      }

      input[type="file"] {
        padding: 8px;
        background-color: var(--dark-surface);
        border: 1px dashed var(--border-color);
      }

      textarea {
        min-height: 120px;
        resize: vertical;
        font-family: "Inter", sans-serif;
      }

      button {
        background: var(--primary-color);
        color: white;
        border: none;
        padding: 12px 18px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 500;
        transition: all 0.3s ease;
        box-shadow: 0 2px 10px rgba(45, 212, 191, 0.2);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
      }

      button:hover {
        background: var(--primary-dark);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(45, 212, 191, 0.3);
      }

      button.secondary {
        background: var(--secondary-color);
        box-shadow: 0 2px 10px rgba(139, 92, 246, 0.2);
      }

      button.secondary:hover {
        background: var(--secondary-dark);
        box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
      }

      button:disabled {
        background: #3a3a3a;
        color: #888;
        cursor: not-allowed;
        box-shadow: none;
        transform: none;
      }

      .status {
        margin-top: 10px;
        color: var(--primary-color);
        font-size: 14px;
      }

      .error {
        color: var(--error-color);
      }

      .success {
        color: var(--success-color);
      }

      .warning {
        color: var(--warning-color);
      }

      .info {
        color: var(--info-color);
      }

      .node-info {
        display: inline-block;
        margin-right: 10px;
        background: var(--dark-surface);
        padding: 4px 8px;
        border-radius: 4px;
        color: var(--text-color);
        border: 1px solid var(--border-color);
      }

      .message {
        background: var(--dark-surface);
        border-left: 4px solid var(--primary-color);
        padding: 10px;
        margin-bottom: 10px;
        border-radius: 0 4px 4px 0;
      }

      .message-header {
        display: flex;
        justify-content: space-between;
        font-size: 0.9em;
        color: var(--text-light);
        margin-bottom: 5px;
      }

      .message-name {
        font-weight: bold;
        color: var(--primary-color);
      }

      .message-source {
        font-size: 0.8em;
        color: #999;
        background: #f0f0f0;
        padding: 2px 5px;
        border-radius: 3px;
      }

      .message-ipfs {
        border-left-color: var(--secondary-color);
      }

      .message-ipfs .message-name {
        color: var(--secondary-color);
      }

      .log-container {
        background: var(--dark-bg);
        color: #eee;
        font-family: monospace;
        padding: 10px;
        height: 150px;
        overflow-y: auto;
        border-radius: 4px;
        margin-top: 10px;
        font-size: 12px;
      }

      .log-info {
        color: var(--success-color);
      }

      .log-error {
        color: var(--error-color);
      }

      .log-warn {
        color: var(--warning-color);
      }

      .tabs {
        display: flex;
        margin-bottom: 24px;
        border-bottom: 1px solid var(--border-color);
        gap: 4px;
      }

      .tab {
        padding: 12px 20px;
        background: var(--dark-surface);
        cursor: pointer;
        border-radius: 8px 8px 0 0;
        transition: all 0.3s ease;
        font-weight: 500;
        position: relative;
        overflow: hidden;
        border: 1px solid transparent;
        border-bottom: none;
      }

      .tab:hover {
        background: rgba(45, 212, 191, 0.1);
      }

      .tab::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        width: 0;
        height: 3px;
        background: var(--primary-color);
        transition: width 0.3s ease;
      }

      .tab:hover::after {
        width: 100%;
      }

      .tab.active {
        background: rgba(45, 212, 191, 0.15);
        color: var(--primary-color);
        border-color: var(--border-color);
        border-bottom-color: transparent;
      }

      .tab.active::after {
        width: 100%;
      }

      .tab-content {
        display: none;
        animation: fadeIn 0.5s ease;
      }

      .tab-content.active {
        display: block;
      }

      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
      }

      #debug-toggle {
        font-size: 12px;
        padding: 5px 10px;
        background: #666;
      }

      .file-list {
        max-height: 600px;
        overflow-y: auto;
        border-radius: 10px;
        padding: 0 2px;
      }

      .file-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 16px;
        border-bottom: 1px solid var(--border-color);
        background: var(--dark-surface);
        margin-bottom: 10px;
        border-radius: 8px;
        transition: all 0.3s ease;
        transform-origin: center;
      }

      .file-item:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
        border-color: var(--primary-dark);
      }

      .file-item:last-child {
        border-bottom: 1px solid var(--border-color);
      }

      .file-info {
        flex: 1;
        padding-right: 12px;
      }

      .file-name {
        font-weight: 600;
        font-size: 16px;
        color: var(--text-color);
        margin-bottom: 6px;
        display: block;
      }

      .file-meta {
        font-size: 13px;
        color: var(--text-secondary);
        line-height: 1.5;
      }

      .file-actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        justify-content: flex-end;
      }

      .file-actions button {
        padding: 8px 12px;
        font-size: 13px;
        border-radius: 6px;
        min-width: 100px;
      }

      .search-form {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 10px;
        margin-bottom: 15px;
      }

      .search-form input {
        margin-bottom: 0;
      }

      .search-form button {
        grid-column: 1 / -1;
      }

      .ipfs-badge {
        display: inline-block;
        background: var(--secondary-color);
        color: white;
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 12px;
        margin-left: 5px;
      }

      .local-badge {
        display: inline-block;
        background: var(--primary-color);
        color: white;
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 12px;
        margin-left: 5px;
      }

      .loading {
        text-align: center;
        padding: 20px;
        color: var(--text-light);
      }

      .empty-state {
        text-align: center;
        padding: 30px;
        color: var(--text-light);
      }

      .empty-state i {
        font-size: 48px;
        margin-bottom: 10px;
        color: var(--border-color);
      }

      .dashboard-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }

      .dashboard-title {
        margin: 0;
      }

      .dashboard-actions {
        display: flex;
        gap: 10px;
      }

      .ipfs-info {
        margin-top: 5px;
        font-size: 12px;
        color: var(--text-secondary);
        background: var(--dark-surface);
        padding: 8px;
        border-radius: 6px;
        word-break: break-all;
        border: 1px solid var(--border-color);
      }

      .ipfs-info small {
        font-family: monospace;
        display: block;
        margin: 4px 0;
      }

      .ipfs-info a {
        color: var(--secondary-color);
        text-decoration: none;
      }

      .ipfs-info a:hover {
        text-decoration: underline;
      }

      .copy-hash {
        background: var(--secondary-color) !important;
      }

      .copy-hash:hover {
        background: var(--secondary-dark) !important;
      }

      @media (max-width: 768px) {
        .grid {
          grid-template-columns: 1fr;
        }

        .search-form {
          grid-template-columns: 1fr;
        }

        .dashboard-header {
          flex-direction: column;
          align-items: flex-start;
          gap: 10px;
        }

        .dashboard-actions {
          width: 100%;
          justify-content: space-between;
        }
      }

      .badge {
        display: inline-block;
        padding: 6px 10px;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 600;
        background-color: var(--dark-surface);
        color: var(--text-color);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        border: 1px solid var(--border-color);
      }

      .breadcrumb {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 20px;
        padding: 12px;
        background-color: var(--dark-surface);
        border-radius: 8px;
        border: 1px solid var(--border-color);
      }

      .crumb {
        cursor: pointer;
        padding: 5px 10px;
        border-radius: 6px;
        font-weight: 500;
        transition: all 0.2s ease;
        background-color: rgba(45, 212, 191, 0.1);
        color: var(--text-color);
      }

      .crumb:hover {
        background-color: rgba(45, 212, 191, 0.25);
        color: var(--primary-color);
      }

      .crumb:not(:last-child)::after {
        content: "/";
        margin-left: 8px;
        color: var(--text-secondary);
        font-weight: 300;
      }

      .explorer-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 16px;
        margin-bottom: 10px;
        background-color: var(--dark-surface);
        border-radius: 8px;
        border: 1px solid var(--border-color);
        transition: all 0.3s ease;
      }

      .explorer-item:hover {
        background-color: rgba(45, 212, 191, 0.1);
        border-color: var(--primary-color);
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
      }

      .explorer-item.clickable {
        cursor: pointer;
      }

      .explorer-name {
        font-weight: 600;
        color: var(--text-color);
      }

      .explorer-preview {
        font-size: 13px;
        color: var(--text-secondary);
        margin-top: 5px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 500px;
      }

      .explorer-type {
        padding: 4px 8px;
        border-radius: 6px;
        background-color: var(--dark-card);
        border: 1px solid var(--border-color);
        font-size: 12px;
        font-weight: 500;
        color: var(--primary-color);
      }

      .settings-group {
        margin-bottom: 25px;
        padding: 20px;
        background-color: var(--dark-surface);
        border-radius: 8px;
        border: 1px solid var(--border-color);
      }

      .settings-group h4 {
        margin-top: 0;
        margin-bottom: 15px;
        padding-bottom: 8px;
        border-bottom: 1px solid var(--border-color);
        color: var(--primary-color);
      }

      .setting-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }

      .switch-container {
        display: flex;
        align-items: center;
      }

      .switch {
        position: relative;
        display: inline-block;
        width: 48px;
        height: 24px;
        margin-right: 10px;
      }

      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }

      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #444;
        transition: 0.4s;
        box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);
      }

      .slider:before {
        position: absolute;
        content: "";
        height: 18px;
        width: 18px;
        left: 3px;
        bottom: 3px;
        background-color: var(--text-color);
        transition: 0.4s;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
      }

      input:checked + .slider {
        background-color: var(--primary-color);
      }

      input:checked + .slider:before {
        transform: translateX(24px);
      }

      .slider.round {
        border-radius: 24px;
      }

      .slider.round:before {
        border-radius: 50%;
      }

      .form-group {
        margin-bottom: 15px;
      }

      .form-control {
        width: 100%;
        padding: 12px;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        font-size: 14px;
        background-color: var(--dark-surface);
        color: var(--text-color);
        transition: all 0.3s ease;
      }
      
      .form-control:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 2px rgba(45, 212, 191, 0.2);
      }

      select.form-control {
        height: 45px;
        appearance: none;
        background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23e2e8f0%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
        background-repeat: no-repeat;
        background-position: right 12px top 50%;
        background-size: 12px auto;
        padding-right: 30px;
      }

      .btn {
        display: inline-block;
        padding: 8px 15px;
        font-size: 14px;
        border-radius: 4px;
        cursor: pointer;
        border: none;
        text-align: center;
      }

      .btn.primary {
        background-color: var(--primary-color);
        color: white;
        transition: all 0.3s ease;
        box-shadow: 0 2px 8px rgba(45, 212, 191, 0.3);
        border-radius: 6px;
      }

      .btn.primary:hover {
        background-color: var(--primary-dark);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(45, 212, 191, 0.4);
      }

      .conditional-config {
        padding: 15px;
        margin: 15px 0;
        background-color: var(--dark-card);
        border-radius: 8px;
        border: 1px solid var(--border-color);
        border-left: 3px solid var(--primary-color);
      }

      .view-file-btn {
        background-color: var(--primary-color);
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
      }

      .view-file-btn:hover {
        background-color: var(--primary-dark);
      }

      .copy-hash-btn {
        background-color: var(--secondary-color);
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
      }

      .copy-hash-btn:hover {
        background-color: var(--secondary-dark);
      }

      /* Pin/Unpin buttons styles */
      .pin-button,
      .unpin-button {
        background-color: #6c5ce7;
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        margin-left: 5px;
      }

      .pin-button:hover {
        background-color: #5541d8;
      }

      .unpin-button {
        background-color: #636e72;
      }

      .unpin-button:hover {
        background-color: #4d5b5e;
      }

      .pin-status {
        display: inline-block;
        font-size: 12px;
        padding: 2px 6px;
        border-radius: 3px;
        margin-left: 5px;
      }

      .pinned {
        background-color: #6c5ce7;
        color: white;
      }

      .unpinned {
        background-color: #636e72;
        color: white;
      }

      /* Stili per la Sezione Esplora GunDB */
      #gundb-explorer {
        margin-top: 20px;
      }

      .gundb-explorer-toolbar {
        display: flex;
        justify-content: flex-end;
        margin-bottom: 10px;
        gap: 10px;
      }

      .gundb-path-container {
        font-weight: bold;
        margin-bottom: 15px;
        padding: 8px;
        background-color: #f5f5f5;
        border-radius: 4px;
      }

      .gundb-nodes {
        display: grid;
        gap: 10px;
      }

      .gundb-node {
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 10px;
        display: grid;
        grid-template-columns: 2fr 3fr auto auto;
        align-items: center;
        gap: 10px;
        background-color: #f9f9f9;
      }

      .node-key {
        font-weight: bold;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .node-value {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        max-width: 100%;
        color: #555;
      }

      .node-type {
        color: #888;
        font-style: italic;
      }

      .node-actions {
        display: flex;
        justify-content: flex-end;
      }

      .explore-node {
        background-color: #4caf50;
        color: white;
        border: none;
        padding: 5px 10px;
        border-radius: 4px;
        cursor: pointer;
      }

      .explore-node:hover {
        background-color: #3e8e41;
      }

      #gundb-content .loading,
      #gundb-content .error,
      #gundb-content .empty {
        padding: 20px;
        text-align: center;
        border-radius: 4px;
      }

      #gundb-content .loading {
        background-color: #f0f0f0;
        color: #555;
      }

      #gundb-content .error {
        background-color: #ffebee;
        color: #d32f2f;
      }

      #gundb-content .empty {
        background-color: #f5f5f5;
        color: #757575;
      }

      .gundb-query-container {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
      }

      .gundb-query-container input {
        flex: 1;
        padding: 8px 12px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-family: monospace;
      }

      .gundb-query-container button {
        background-color: var(--primary-color);
        color: white;
        border: none;
        padding: 8px 15px;
        border-radius: 4px;
        cursor: pointer;
      }

      .gundb-query-container button:hover {
        background-color: var(--primary-dark);
      }

      .gundb-query-result {
        margin-top: 15px;
        padding: 15px;
        background-color: var(--dark-surface);
        border-radius: 8px;
        border: 1px solid var(--border-color);
        border-left: 3px solid var(--primary-color);
        overflow-x: auto;
        color: var(--text-color);
      }

      .gundb-query-error {
        margin-top: 15px;
        padding: 15px;
        background-color: rgba(244, 63, 94, 0.1);
        border-radius: 8px;
        border: 1px solid rgba(244, 63, 94, 0.3);
        border-left: 3px solid var(--error-color);
        color: var(--error-color);
      }

      .gundb-examples {
        margin-bottom: 15px;
        padding: 5px 10px;
        background-color: #f5f5f5;
        border-radius: 4px;
        font-size: 13px;
      }

      .gundb-examples span {
        color: #666;
        margin-right: 10px;
      }

      .query-example {
        display: inline-block;
        margin-right: 15px;
        padding: 2px 8px;
        background-color: #e0e0e0;
        border-radius: 3px;
        color: var(--primary-color);
        text-decoration: none;
        font-family: monospace;
      }

      .query-example:hover {
        background-color: #d0d0d0;
        text-decoration: none;
      }

      /* Toast notification system */
      .toast-container {
        position: fixed;
        top: 20px;
        right: 20px;
        max-width: 300px;
        z-index: 9999;
      }

      .toast {
        background-color: #333;
        color: white;
        padding: 12px 15px;
        border-radius: 4px;
        margin-bottom: 10px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        display: flex;
        justify-content: space-between;
        align-items: center;
        animation: slidein 0.3s ease-out;
      }

      @keyframes slidein {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      .toast-success {
        background-color: var(--success-color);
      }

      .toast-error {
        background-color: var(--error-color);
      }

      .toast-warning {
        background-color: var(--warning-color);
        color: #333;
      }

      .toast-info {
        background-color: var(--info-color);
      }

      .toast-close {
        background: transparent;
        border: none;
        color: white;
        font-size: 16px;
        cursor: pointer;
        padding: 0 0 0 10px;
        margin: 0;
      }

      .toast-warning .toast-close {
        color: #333;
      }

      /* Enhanced loading spinner */
      .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        visibility: hidden;
        opacity: 0;
        transition: opacity 0.3s, visibility 0.3s;
      }

      .loading-overlay.active {
        visibility: visible;
        opacity: 1;
      }

      .loading-spinner {
        width: 50px;
        height: 50px;
        border: 5px solid #f3f3f3;
        border-top: 5px solid var(--primary-color);
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* IPFS Connection status styles */
      .connection-status {
        margin: 15px 0;
        padding: 15px;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        background-color: var(--dark-surface);
        display: flex;
        align-items: center;
        gap: 12px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
      }
      
      .status-label {
        font-weight: 600;
        color: var(--text-color);
      }
      
      .status-connected {
        color: #4CAF50;
        font-weight: bold;
      }
      
      .status-error {
        color: #ff3366;
        font-weight: bold;
      }
      
      .status-checking {
        color: #ff9800;
        font-weight: bold;
      }
      
      .status-disabled {
        color: #777;
        font-style: italic;
      }
      
      .status-unknown {
        color: #999;
      }
      
      .btn-small {
        padding: 6px 12px;
        font-size: 0.8rem;
        background-color: var(--info-color);
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }
      
      .btn-small:hover {
        background-color: var(--primary-color);
        transform: translateY(-1px);
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
      }
      
      .btn-warning {
        background-color: var(--warning-color);
        color: #333;
      }
      
      .btn-warning:hover {
        background-color: #e6b800;
      }
    </style>
  </head>

  <body>
    <header>
      <h1>Shogun Relay Dashboard</h1>
    </header>

    <div class="navbar">
      <div class="nav-links">
        <a href="/" class="active">Dashboard</a>
      </div>
      <button id="logout-btn" class="logout-btn">Logout</button>
    </div>

    <div class="container">
      <!-- Toast container for notifications -->
      <div id="toast-container" class="toast-container"></div>

      <!-- Loading overlay -->
      <div id="loading-overlay" class="loading-overlay">
        <div class="loading-spinner"></div>
      </div>

      <div class="dashboard-header">
        <h2 class="dashboard-title">System Overview</h2>
        <div class="dashboard-actions">
          <button id="refresh-all">Refresh Data</button>
        </div>
      </div>

      <div class="grid">
        <div class="stat-card">
          <div class="stat-label">Server Status</div>
          <div class="stat-value" id="server-status">Active</div>
          <div class="stat-label">
            Port: <span id="server-port">8765</span>
          </div>
        </div>
        <div class="stat-card">
          <div class="stat-label">GunDB Connections</div>
          <div class="stat-value" id="peer-count">0</div>
          <div class="stat-label">
            Status: <span id="network-status">Starting...</span>
          </div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Files Uploaded</div>
          <div class="stat-value" id="file-count">0</div>
          <div class="stat-label">
            Total: <span id="total-size">0 MB</span>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="card-header">
          <h3 class="card-title">Server Information</h3>
        </div>
        <p>
          Gun server active on <code><span id="origin"></span></code>
        </p>
        <p>
          WebSocket on <code><span id="ws"></span></code>
        </p>
        <div id="network-info">
          <span class="node-info"
            >Peers: <strong id="peer-count-detail">0</strong></span
          >
          <span class="node-info"
            >Status: <strong id="network-status-detail">Starting...</strong></span
          >
        </div>
        <div
          id="log-container"
          class="log-container"
          style="display: none"
        ></div>
      </div>

      <div class="card">
        <div class="tabs">
          <div class="tab active" data-tab="files">Files</div>
          <div class="tab" data-tab="upload">Upload File</div>
          <div class="tab" data-tab="settings">Settings</div>
        </div>

        <div id="files-tab" class="tab-content active">
          <div class="card-header">
            <h3 class="card-title">File Management</h3>
            <div class="card-actions">
              <button id="refresh-files">Refresh</button>
            </div>
          </div>

          <div class="search-form">
            <input type="text" id="file-name-search" placeholder="File name" />
            <input
              type="text"
              id="file-mimetype-search"
              placeholder="MIME type"
            />
            <input
              type="number"
              id="file-min-size"
              placeholder="Min size (bytes)"
            />
            <input
              type="number"
              id="file-max-size"
              placeholder="Max size (bytes)"
            />
            <button id="search-files">Search</button>
          </div>

          <div class="file-list" id="file-list">
            <div class="loading">Loading files...</div>
          </div>
        </div>

        <div id="upload-tab" class="tab-content">
          <div class="card-header">
            <h3 class="card-title">Upload File</h3>
            <div class="card-actions">
              <span id="ipfs-status-badge" class="badge"
                >IPFS: Disabled</span
              >
            </div>
          </div>

          <form id="upload-form">
            <input type="file" id="file-input" />
            <input
              type="text"
              id="custom-name"
              placeholder="Custom name (optional)"
            />
            <button type="submit" id="upload-button">Upload File</button>
            <div id="upload-status" class="status"></div>
          </form>

          <div id="upload-result" style="margin-top: 20px"></div>
        </div>



        <div id="settings-tab" class="tab-content">
          <div class="card-header">
            <h3 class="card-title">Settings</h3>
          </div>

          <div class="settings-group">
            <h4>IPFS</h4>
            <div class="setting-item">
              <label for="ipfs-switch">Enable IPFS storage</label>
              <div class="switch-container">
                <label class="switch">
                  <input type="checkbox" id="ipfs-switch" />
                  <span class="slider round"></span>
                </label>
                <span id="ipfs-status">Disabled</span>
              </div>
            </div>
            
            <!-- Connection status indicator -->
            <div id="ipfs-connection-status" class="connection-status">
              <span class="status-label">Connection status:</span>
              <span id="ipfs-status-indicator" class="status-unknown">Unknown</span>
              <button id="ipfs-check-connection" class="btn-small">Check</button>
              <button id="ipfs-reconnect" class="btn-small btn-warning" style="display:none;">Reconnect</button>
            </div>
            
            <div class="form-group">
              <label for="ipfs-service">IPFS Service</label>
              <select id="ipfs-service" class="form-control">
                <option value="IPFS-CLIENT">IPFS Client (Local)</option>
                <option value="PINATA">Pinata Cloud</option>
              </select>
            </div>

            <!-- Authentication section -->
            <h4 style="margin-top: 20px">Authentication</h4>
            <div class="setting-item">
              <label for="auth-token">Authentication Token</label>
              <div style="display: flex; gap: 10px">
                <input
                  type="password"
                  id="auth-token"
                  class="form-control"
                  placeholder="Enter authentication token"
                />
                <button id="save-token" class="btn primary">Save</button>
              </div>
              <div id="auth-status" class="status"></div>
            </div>

            <div id="ipfs-config-form" style="margin-top: 20px">
              <div class="form-group">
                <label for="ipfs-service">IPFS Service</label>
                <select id="ipfs-service" class="form-control">
                  <option value="IPFS-CLIENT">Local IPFS Client</option>
                  <option value="PINATA">Pinata</option>
                </select>
              </div>

              <div id="ipfs-client-config" class="conditional-config">
                <div class="form-group">
                  <label for="ipfs-node-url">IPFS Node URL</label>
                  <input
                    type="text"
                    id="ipfs-node-url"
                    class="form-control"
                    placeholder="http://localhost:5001"
                  />
                </div>
              </div>

              <div
                id="pinata-config"
                class="conditional-config"
                style="display: none"
              >
                <div class="form-group">
                  <label for="pinata-jwt">Pinata JWT</label>
                  <input
                    type="text"
                    id="pinata-jwt"
                    class="form-control"
                    placeholder="JWT Token"
                  />
                </div>
              </div>

              <div class="form-group">
                <label for="ipfs-gateway">IPFS Gateway</label>
                <input
                  type="text"
                  id="ipfs-gateway"
                  class="form-control"
                  placeholder="https://ipfs.io/ipfs"
                />
              </div>

              <button id="save-ipfs-config" class="btn primary">
                Save Configuration
              </button>
              <div id="ipfs-config-status" class="status"></div>
            </div>
          </div>
        </div>
      </div>


    </div>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        // Toast notification system
        const toastContainer = document.getElementById("toast-container");
        const showToast = (message, type = "info", duration = 5000) => {
          const toast = document.createElement("div");
          toast.className = `toast toast-${type}`;

          const content = document.createElement("div");
          content.textContent = message;

          const closeBtn = document.createElement("button");
          closeBtn.className = "toast-close";
          closeBtn.innerHTML = "âœ•";
          closeBtn.addEventListener("click", () => {
            toast.remove();
          });

          toast.appendChild(content);
          toast.appendChild(closeBtn);
          toastContainer.appendChild(toast);

          setTimeout(() => {
            toast.style.opacity = "0";
            toast.style.transform = "translateX(100%)";
            toast.style.transition = "all 0.3s ease-out";
            setTimeout(() => toast.remove(), 300);
          }, duration);

          return toast;
        };

        // Tab system management (migliorato)
        const tabs = document.querySelectorAll(".tab");
        const tabContents = document.querySelectorAll(".tab-content");

        tabs.forEach((tab) => {
          tab.addEventListener("click", () => {
            // Remove active class from all tabs
            tabs.forEach((t) => t.classList.remove("active"));
            // Add active class to clicked tab
            tab.classList.add("active");

            // Hide all tab contents
            tabContents.forEach((content) =>
              content.classList.remove("active")
            );

            // Show content for clicked tab
            const tabName = tab.getAttribute("data-tab");
            const tabContent = document.getElementById(`${tabName}-tab`);
            if (tabContent) {
              tabContent.classList.add("active");
              logger.info(`Tab changed to: ${tabName}`);

                              // Inizializza automaticamente specifiche tabs
                if (tabName === "files") {
                // Non caricare automaticamente i file quando si attiva la tab
                console.log("Tab files attivata - nessun caricamento automatico");
              }
            }
          });
        });

        // Loading overlay management
        const loadingOverlay = document.getElementById("loading-overlay");
        const showLoading = () => {
          loadingOverlay.classList.add("active");
        };
        const hideLoading = () => {
          loadingOverlay.classList.remove("active");
        };

        // JWT token management
        const getAuthToken = () => {
          return localStorage.getItem("authToken");
        };

        const getTokenData = () => {
          const token = getAuthToken();
          if (!token) return null;

          // Admin token is always valid with no expiration
          if (token === "thisIsTheTokenForReals") {
            return {
              exp: Math.floor(Date.now() / 1000) + 365 * 24 * 60 * 60, // Set exp far in the future (1 year)
            };
          }

          try {
            // JWT tokens are base64 encoded with 3 parts: header.payload.signature
            const parts = token.split(".");
            if (parts.length !== 3) return null;

            // Decode the payload (middle part)
            const payload = JSON.parse(atob(parts[1]));
            return payload;
          } catch (e) {
            console.error("Error parsing token:", e);
            return null;
          }
        };

        const isTokenExpired = () => {
          const tokenData = getTokenData();
          if (!tokenData || !tokenData.exp) return true;

          // Admin token never expires
          const token = getAuthToken();
          if (token === "thisIsTheTokenForReals") return false;

          // exp is in seconds, Date.now() is in milliseconds
          return tokenData.exp * 1000 < Date.now();
        };

        const refreshToken = async () => {
          try {
            showLoading();

            // Get the current token
            const token = getAuthToken();

            // Skip refresh for admin token
            if (token === "thisIsTheTokenForReals") {
              console.log("Admin token detected, no refresh needed");
              return true;
            }

            // Only try to refresh actual JWT tokens
            if (!token || token.split(".").length !== 3) {
              console.log("Not a JWT token, skipping refresh");
              return true;
            }

            const response = await fetch("/api/auth/refresh-token", {
              method: "POST",
              headers: {
                Authorization: `Bearer ${getAuthToken()}`,
              },
            });

            if (!response.ok) {
              throw new Error("Token refresh failed");
            }

            const data = await response.json();
            if (data.token) {
              localStorage.setItem("authToken", data.token);
              showToast("Session renewed", "success");
              return true;
            }
            return false;
          } catch (error) {
            console.error("Error refreshing token:", error);
            showToast(
              "Unable to renew session. Please try logging in again.",
              "error"
            );
            return false;
          } finally {
            hideLoading();
          }
        };

        // Check authentication & token status
        const checkAuth = async () => {
          const token = getAuthToken();
          if (!token) {
            // Redirect to login page if no token
            window.location.href = "/login";
            return false;
          }

          // Admin token is always valid
          if (token === "thisIsTheTokenForReals") {
            return true;
          }

          // Only check expiration for JWT tokens (they have 3 parts separated by dots)
          if (token.split(".").length === 3) {
            // Check if token is expired
            if (isTokenExpired()) {
              // Try to refresh token
              const refreshed = await refreshToken();
              if (!refreshed) {
                // If refresh failed, redirect to login
                localStorage.removeItem("authToken");
                window.location.href = "/login";
                return false;
              }
            }
          }

          return true;
        };

        // Check auth immediately and setup periodic checks
        checkAuth();

        // Setup token refresh every 5 minutes if needed
        setInterval(async () => {
          // Only refresh if token exists but is getting close to expiration (within 5 minutes)
          const tokenData = getTokenData();
          if (tokenData && tokenData.exp) {
            const expiresIn = tokenData.exp * 1000 - Date.now();
            if (expiresIn > 0 && expiresIn < 5 * 60 * 1000) {
              await refreshToken();
            }
          }
        }, 60 * 1000); // Check every minute

        // Logger enhancements
        const logContainer = document.getElementById("log-container");
        const logger = {
          log: function (message, type = "info") {
            const logItem = document.createElement("div");
            logItem.className = `log-${type}`;
            logItem.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logContainer.appendChild(logItem);
            logContainer.scrollTop = logContainer.scrollHeight;
            console.log(`[${type}] ${message}`);
          },
          info: function (message) {
            this.log(message, "info");
          },
          error: function (message) {
            this.log(message, "error");
            showToast(message, "error");
          },
          warn: function (message) {
            this.log(message, "warn");
          },
          success: function (message) {
            this.log(message, "info");
            showToast(message, "success");
          },
        };

        // Debug logs are now handled by the debug-command-btn in the navbar

        // Initialize Gun with connection to relay
        logger.info(
          "Initializing Gun with server: " + location.origin + "/gun"
        );

        // Checks if WebSocket is supported
        if (typeof WebSocket === "undefined") {
          logger.error(
            "WebSocket not supported in this browser! Using HTTP fallback"
          );
        } else {
          logger.info(
            "WebSocket supported, attempting WebSocket connection..."
          );
        }

        // Create WebSocket URL
        const wsProtocol =
          window.location.protocol === "https:" ? "wss:" : "ws:";
        const wsUrl = wsProtocol + "//" + window.location.host + "/gun";
        logger.info("WebSocket URL: " + wsUrl);

        // Function to initialize Gun with improved options
        const initializeGun = () => {
          logger.info("Initializing GunDB with retry and optimized options");

          return Gun({
            peers: [location.origin + "/gun"],
            localStorage: false,
            radisk: false,
            WebSocket: window.WebSocket,
            secure: window.location.protocol === "https:",
            headers: {
              Authorization: `Bearer ${getAuthToken()}`,
            },
            retry: 1000, // Retry connection every 1 second
            recover: true, // Enable recovery
            chunk: 1024, // Chunk size
            lack: 1000, // Timeout for message receipt
          });
        };

        // Initialize Gun
        const gun = initializeGun();
        window.Gun = gun;

        // Improved connection handling
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 5;
        const reconnectDelay = 2000; // 2 seconds

        // Function to reconnect Gun in case of problems
        const reconnectGun = () => {
          if (reconnectAttempts >= maxReconnectAttempts) {
            logger.error(
              `Maximum number of reconnection attempts reached (${maxReconnectAttempts})`
            );
            showToast(
              "Unable to connect to Gun server. Please reload the page.",
              "error"
            );
            return;
          }

          reconnectAttempts++;
          logger.warn(
            `GunDB reconnection attempt ${reconnectAttempts}/${maxReconnectAttempts}...`
          );

          // Force a new connection by sending a ping
          setTimeout(() => {
            try {
              gun.get("_ping").put({ timestamp: Date.now() });
            } catch (err) {
              logger.error(`Reconnection error: ${err.message}`);
            }
          }, reconnectDelay);
        };

        // Add token to ALL gun messages with proper authorization header
        Gun.on("opt", function (ctx) {
          if (ctx.once) return;

          // Intercept all outgoing messages
          ctx.on("out", function (msg) {
            // Make sure headers exist
            if (!msg.headers) msg.headers = {};

            // Add auth token to headers
            const token = getAuthToken();
            if (token) {
              msg.headers.Authorization = `Bearer ${token}`;
            }

            this.to.next(msg);
          });
        });

        // Test WebSocket connection with loading indicator
        showLoading();
        fetch("/check-websocket")
          .then((res) => res.json())
          .then((data) => {
            logger.info(
              "WebSocket server configuration: " + JSON.stringify(data)
            );
            hideLoading();
          })
          .catch((err) => {
            logger.error("WebSocket verification error: " + err.message);
            hideLoading();
          });

        // Basic connection status variables
        const peerCountEl = document.getElementById("peer-count");
        const peerCountDetailEl = document.getElementById("peer-count-detail");
        const networkStatusEl = document.getElementById("network-status");
        const networkStatusDetailEl = document.getElementById(
          "network-status-detail"
        );
        const serverStatusEl = document.getElementById("server-status");
        const serverPortEl = document.getElementById("server-port");

        document.getElementById("origin").textContent = location.origin;
        document.getElementById("ws").textContent =
          location.origin.replace(/^http/, "ws") + "/gun";
        serverPortEl.textContent = location.port || "8765";

        let peerCount = 0;
        let connectionStatus = "Disconnected";

        // Listen to connection events
        gun.on("hi", (peer) => {
          peerCount++;
          connectionStatus = "Connected";
          updateConnectionStatus();
          logger.info(`Connected to peer: ${JSON.stringify(peer)}`);

          // Reset reconnection attempts counter
          reconnectAttempts = 0;

          // Force a file update when we connect
          setTimeout(() => loadFiles(), 1000);
        });

        gun.on("bye", (peer) => {
          peerCount = Math.max(0, peerCount - 1);
          connectionStatus = peerCount === 0 ? "Disconnected" : "Connected";
          updateConnectionStatus();
          logger.warn(`Disconnected from peer: ${JSON.stringify(peer)}`);

          // If there are no more connections, try to reconnect
          if (peerCount === 0) {
            reconnectGun();
          }
        });

        // Event listener for file updates
        const refreshFilesBtn = document.getElementById("refresh-files");
        refreshFilesBtn.addEventListener("click", async () => {
          try {
            showLoading();
            await loadFiles();
            logger.success("Files updated successfully");
            showToast("Files updated successfully", "success");
          } catch (error) {
            logger.error(`File update error: ${error.message}`);
            showToast(`File update error: ${error.message}`, "error");
          } finally {
            hideLoading();
          }
        });

        // Funzione per aggiornare lo stato della connessione
        function updateConnectionStatus() {
          peerCountEl.textContent = peerCount;
          peerCountDetailEl.textContent = peerCount;
          networkStatusEl.textContent = connectionStatus;
          networkStatusDetailEl.textContent = connectionStatus;
          serverStatusEl.textContent = "Active";

          // Se lo stato Ã¨ cambiato a "Connected", tenta di caricare i file
          if (connectionStatus.includes("Connected")) {
            loadFiles();
          }
        }

        // Refresh globale migliorato
        document
          .getElementById("refresh-all")
          .addEventListener("click", async () => {
            try {
              showLoading();
              logger.info("Aggiornamento globale dati...");

              // Forza un ping per testare la connessione
              gun.get("_ping").put({ timestamp: Date.now() });

              // Aggiorna files e stato IPFS
              await Promise.all([loadFiles(), updateIpfsStatus()]);

              logger.success("Dati aggiornati con successo");
              showToast("Dati aggiornati con successo", "success");
            } catch (error) {
              logger.error(`Errore aggiornamento dati: ${error.message}`);
              showToast(`Errore aggiornamento: ${error.message}`, "error");
            } finally {
              hideLoading();
            }
          });

        // Set a forced initial connection
        setTimeout(() => {
          // If after 3 seconds we are still disconnected, force a connection
          if (connectionStatus === "Disconnected") {
            logger.info("Forced connection attempt...");
            gun.get("_").put({ ping: Date.now() });

            // If the server is active but we don't have peers, consider the connection valid anyway
            if (connectionStatus === "Disconnected") {
              connectionStatus = "Connected (Local Only)";
              updateConnectionStatus();
              logger.info("Local connection established");

              // Load files with local connection
              loadFiles();
            }
          }
        }, 3000);

        // File management with enhanced loading and error handling
        const fileList = document.getElementById("file-list");
        const fileCountEl = document.getElementById("file-count");
        const totalSizeEl = document.getElementById("total-size");
        const searchFilesBtn = document.getElementById("search-files");

        // Load all files - Using ONLY REST API, no direct GunDB access
        const loadFiles = async (searchParams = {}) => {
          showLoading();
          fileList.innerHTML =
            '<div class="loading">Loading files...</div>';

          try {
            // Check auth before proceeding
            if (!(await checkAuth())) {
              hideLoading();
              return;
            }

            // Construct URL with search parameters
            let url = "/files/all"; // Use the dedicated REST endpoint
            if (Object.keys(searchParams).length > 0) {
              const queryParams = new URLSearchParams();
              for (const key in searchParams) {
                if (searchParams[key]) {
                  queryParams.append(key, searchParams[key]);
                }
              }
              url = `/files/search?${queryParams.toString()}`;
            }

            const token = getAuthToken();
            const response = await fetch(url, {
              headers: {
                Authorization: `Bearer ${token}`,
              },
            });

            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();

            if (data.success) {
              // Support both 'files' and 'results' property names for compatibility
              const fileArray = data.files || data.results || [];

              if (fileArray.length > 0) {
                displayFiles(fileArray);
                updateFileStats(fileArray);
                logger.success(`Loaded ${fileArray.length} files from REST API`);
              } else {
                fileList.innerHTML =
                  '<div class="empty-state">No files found</div>';
                updateFileStats([]);
                logger.warn("No files found via API");
              }
            } else {
              fileList.innerHTML =
                '<div class="empty-state">No files found</div>';
              updateFileStats([]);
              logger.warn("No files found via API");
            }
          } catch (error) {
            fileList.innerHTML = `<div class="error">Error loading files: ${error.message}</div>`;
            logger.error(`Error loading files: ${error.message}`);
          } finally {
            hideLoading();
          }
        };

        // File upload handler with enhanced confirmation and loading
        const uploadForm = document.getElementById("upload-form");
        uploadForm.addEventListener("submit", async (event) => {
          event.preventDefault();

          // Verify authentication
          if (!(await checkAuth())) {
            showToast("Autenticazione richiesta per caricare file", "error");
            return;
          }

          const fileInput = document.getElementById("file-input");
          const customName = document.getElementById("custom-name").value;
          const uploadStatus = document.getElementById("upload-status");
          const uploadResult = document.getElementById("upload-result");

          if (!fileInput.files || fileInput.files.length === 0) {
            showToast("Seleziona un file da caricare", "warning");
            uploadStatus.innerHTML =
              '<div class="error">Seleziona un file da caricare</div>';
            return;
          }

          const file = fileInput.files[0];

          // Show loading
          showLoading();
          uploadStatus.innerHTML =
            '<div class="info">Caricamento in corso...</div>';

          try {
            const formData = new FormData();
            formData.append("file", file);
            if (customName) {
              formData.append("customName", customName);
            }

            const response = await fetch("/upload", {
              method: "POST",
              headers: {
                Authorization: `Bearer ${getAuthToken()}`,
              },
              body: formData,
            });

            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();

            if (data.success) {
              uploadStatus.innerHTML =
                '<div class="success">File caricato con successo</div>';
              showToast("File caricato con successo", "success");

              // Show upload details
              let resultHtml = `
                <div class="card">
                    <div class="card-header">
                        <h3 class="card-title">File Caricato</h3>
                    </div>
                    <div class="file-info">
                        <div class="file-name">${data.file.originalName}</div>
                        <div class="file-meta">
                            ${formatFileSize(data.file.size)} • ${
                data.file.mimeType
              }
                            ${
                              data.file.ipfsHash
                                ? '<span class="ipfs-badge">IPFS</span>'
                                : '<span class="local-badge">Locale</span>'
                            }
                        </div>
                        <div class="file-url">
                            <strong>URL:</strong> <a href="${
                              data.file.fileUrl
                            }" target="_blank">${data.file.fileUrl}</a>
                        </div>
                        ${
                          data.file.ipfsHash
                            ? `
                            <div class="ipfs-info">
                                <small>IPFS Hash: ${data.file.ipfsHash}</small><br>
                                <small>IPFS URL: <a href="${data.file.ipfsUrl}" target="_blank">${data.file.ipfsUrl}</a></small>
                            </div>
                        `
                            : ""
                        }
                    </div>
                </div>
              `;

              uploadResult.innerHTML = resultHtml;

              // Reload files list after successful upload - using REST API
              setTimeout(() => loadFiles(), 1000);

              // Reset form
              uploadForm.reset();
            } else {
              throw new Error(data.error || "Errore sconosciuto");
            }
          } catch (error) {
            uploadStatus.innerHTML = `<div class="error">Errore durante l'upload: ${error.message}</div>`;
            showToast(`Errore durante l'upload: ${error.message}`, "error");
            logger.error(`Errore upload file: ${error.message}`);
          } finally {
            hideLoading();
          }
        });

        // Delete a file via REST API
        const deleteFile = async (fileId, fileName) => {
          try {
            // Verify authentication
            if (!(await checkAuth())) {
              showToast("Autenticazione richiesta per eliminare file", "error");
              return;
            }

            // Show confirmation dialog
            if (
              !confirm(
                `Sei sicuro di voler eliminare il file "${fileName || fileId}"?`
              )
            ) {
              return;
            }

            // Show loading
            showLoading();
            logger.info(`Eliminazione file: ${fileId}`);

            const response = await fetch(`/files/${fileId}`, {
              method: "DELETE",
              headers: {
                Authorization: `Bearer ${getAuthToken()}`,
              },
            });

            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();

            if (data.success) {
              showToast("File eliminato con successo", "success");
              logger.success(`File eliminato con successo: ${fileId}`);
              // Update file list using REST API
              loadFiles();
            } else {
              throw new Error(data.error || "Errore sconosciuto");
            }
          } catch (error) {
            showToast(
              `Errore durante l'eliminazione: ${error.message}`,
              "error"
            );
            logger.error(`Errore durante l'eliminazione: ${error.message}`);
          } finally {
            hideLoading();
          }
        };

        // Display files in the list
        const displayFiles = (files) => {
          fileList.innerHTML = "";

          files.forEach((file) => {
            const fileItem = document.createElement("div");
            fileItem.className = "file-item";
            // Assign an ID based on the file's ID
            const itemId = `file-${file.id}`;
            fileItem.id = itemId;

            const fileSize = formatFileSize(file.size);
            const uploadDate = new Date(file.uploadedAt).toLocaleString();

            // Determine the URL to use for viewing the file (IPFS or local)
            const viewUrl = file.ipfsUrl || file.fileUrl;

            // Determine storage type
            const storageType = file.ipfsHash
              ? `<span class="ipfs-badge">IPFS</span>`
              : '<span class="local-badge">Locale</span>';

            // Prepare HTML content for IPFS files with pin status
            let ipfsContent = "";
            if (file.ipfsHash) {
              ipfsContent = `
                <div class="ipfs-info">
                    <small>IPFS Hash: ${file.ipfsHash}</small><br>
                    <small>URL: <a href="${file.ipfsUrl}" target="_blank">${file.ipfsUrl}</a></small>
                    <div class="pin-container" id="pin-container-${file.ipfsHash}">
                        <span class="pin-status" id="pin-status-${file.ipfsHash}">Verifica pin...</span>
                    </div>
                </div>`;
            }

            fileItem.innerHTML = `
                <div class="file-info">
                    <div class="file-name">${file.originalName}</div>
                    <div class="file-meta">
                        ${fileSize} • ${file.mimetype} • Caricato: ${uploadDate}
                        ${storageType}
                    </div>
                    ${ipfsContent}
                </div>
                <div class="file-actions">
                    ${
                      viewUrl
                        ? `<button class="view-file" data-url="${viewUrl}">Visualizza File</button>`
                        : ""
                    }
                    ${
                      file.ipfsHash
                        ? `
                        <button class="copy-hash" data-hash="${file.ipfsHash}">Copia Hash</button>
                        <div class="pin-action-buttons" id="pin-buttons-${file.ipfsHash}">
                            <button class="pin-button" data-hash="${file.ipfsHash}" style="display:none">Pin</button>
                            <button class="unpin-button" data-hash="${file.ipfsHash}" style="display:none">Unpin</button>
                        </div>
                    `
                        : ""
                    }
                    <button class="delete-file" data-id="${
                      file.id
                    }" data-name="${
              file.originalName
            }" style="background-color: #ff3366;">Elimina</button>
                </div>
            `;

            fileList.appendChild(fileItem);

            // If it's an IPFS file, check pin status
            if (file.ipfsHash) {
              checkPinStatus(file.ipfsHash);
            }
          });

          // Add event listeners to buttons
          document.querySelectorAll(".view-file").forEach((btn) => {
            btn.addEventListener("click", () => {
              window.open(btn.getAttribute("data-url"), "_blank");
            });
          });

          document.querySelectorAll(".copy-hash").forEach((btn) => {
            btn.addEventListener("click", async () => {
              const hash = btn.getAttribute("data-hash");
              try {
                await navigator.clipboard.writeText(hash);
                alert("Hash IPFS copiato negli appunti");
              } catch (error) {
                alert(`Errore nella copia: ${error.message}`);
              }
            });
          });

          // Add event listeners for pin/unpin buttons
          document.querySelectorAll(".pin-button").forEach((btn) => {
            btn.addEventListener("click", async () => {
              const hash = btn.getAttribute("data-hash");
              await pinFile(hash);
            });
          });

          document.querySelectorAll(".unpin-button").forEach((btn) => {
            btn.addEventListener("click", async () => {
              const hash = btn.getAttribute("data-hash");
              await unpinFile(hash);
            });
          });

          // Add event listener for delete buttons
          document.querySelectorAll(".delete-file").forEach((btn) => {
            btn.addEventListener("click", async () => {
              const fileId = btn.getAttribute("data-id");
              const fileName = btn.getAttribute("data-name");
              await deleteFile(fileId, fileName);
            });
          });
        };

        // Event listener for search form
        searchFilesBtn.addEventListener("click", () => {
          const nameFilter = document.getElementById("file-name-search").value;
          const mimetypeFilter = document.getElementById(
            "file-mimetype-search"
          ).value;
          const minSizeFilter = document.getElementById("file-min-size").value;
          const maxSizeFilter = document.getElementById("file-max-size").value;

          const searchParams = {
            name: nameFilter,
            mimetype: mimetypeFilter,
            minSize: minSizeFilter,
            maxSize: maxSizeFilter,
          };

          loadFiles(searchParams);
        });

        // Update file statistics
        const updateFileStats = (files) => {
          let totalSize = 0;
          files.forEach((file) => {
            totalSize += parseInt(file.size || 0);
          });

          fileCountEl.textContent = files.length;
          totalSizeEl.textContent = formatFileSize(totalSize);
          logger.info(
            `Statistiche aggiornate: ${files.length} file, ${formatFileSize(
              totalSize
            )}`
          );
        };

        // Funzione per formattare le dimensioni dei file
        function formatFileSize(bytes) {
          if (bytes === 0) return "0 Bytes";
          const k = 1024;
          const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
          const i = Math.floor(Math.log(bytes) / Math.log(k));
          return (
            parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i]
          );
        }

        // Funzione per aggiornare lo stato di IPFS nell'interfaccia
        const updateIpfsStatus = async () => {
          try {
            const response = await fetch("/api/ipfs/status", {
              headers: {
                Authorization: `Bearer ${getAuthToken()}`,
              },
            });

            const data = await response.json();

            if (data.success) {
              const isEnabled = data.config.enabled;
              const statusBadge = document.getElementById("ipfs-status-badge");
              const ipfsStatusText = document.getElementById("ipfs-status");
              const ipfsSwitch = document.getElementById("ipfs-switch");

              // Aggiorna il badge di stato
              statusBadge.textContent = isEnabled
                ? "IPFS: Active"
                : "IPFS: Disabled";
              statusBadge.style.backgroundColor = isEnabled
                ? "#4CAF50"
                : "#ff3366";

              // Aggiorna il testo di stato nelle impostazioni
              if (ipfsStatusText) {
                ipfsStatusText.textContent = isEnabled
                  ? "Active"
                  : "Disabled";
              }

              // Aggiorna lo switch
              if (ipfsSwitch) {
                ipfsSwitch.checked = isEnabled;
              }
              
              // Check connection status if IPFS is enabled
              if (isEnabled) {
                checkIpfsConnection();
              }

              // Aggiorna i campi di configurazione
              if (data.config.service) {
                document.getElementById("ipfs-service").value =
                  data.config.service;
                toggleIpfsConfigForms(data.config.service);
              }

              if (data.config.nodeUrl) {
                document.getElementById("ipfs-node-url").value =
                  data.config.nodeUrl;
              }

              if (data.config.gateway) {
                document.getElementById("ipfs-gateway").value =
                  data.config.gateway;
              }

              logger.info(
                `Stato IPFS aggiornato: ${
                  isEnabled ? "Active" : "Disabled"
                }, Servizio: ${data.config.service}`
              );
            } else {
              logger.error("Errore nel recupero dello stato IPFS");
            }
          } catch (error) {
            logger.error(
              `Errore nel controllo dello stato IPFS: ${error.message}`
            );
          }
        };

        // Load files and update IPFS status on page load with proper loading
        showLoading();
        Promise.all([checkAuth(), loadFiles(), updateIpfsStatus()]).finally(
          () => {
            hideLoading();
          }
        );

        // Logout handler - versione migliorata
        document.getElementById("logout-btn").addEventListener("click", () => {
          try {
            // Log dell'azione
            console.log("Logout richiesto, rimozione token...");

            // Rimuovi tutte le possibili chiavi di autenticazione
            localStorage.removeItem("authToken");
            sessionStorage.removeItem("authToken");

            // Forza il reindirizzamento alla pagina di login
            console.log("Reindirizzamento alla pagina di login...");

            // Mostra un messaggio all'utente
            showToast("Logout in corso...", "info", 1000);

            // Attendi brevemente per permettere ai toast di mostrarsi
            setTimeout(() => {
              // Reindirizza con una nuova URL per forzare un refresh completo
              window.location.replace("/login?logout=true");
            }, 500);
          } catch (error) {
            console.error("Errore durante il logout:", error);
            // Fallback nel caso ci siano errori
            window.location.href = "/login";
          }
        });

        // Funzione per cambiare la visualizzazione dei form di configurazione IPFS
        const toggleIpfsConfigForms = (service) => {
          const ipfsClientConfig =
            document.getElementById("ipfs-client-config");
          const pinataConfig = document.getElementById("pinata-config");

          if (service === "PINATA") {
            ipfsClientConfig.style.display = "none";
            pinataConfig.style.display = "block";
          } else {
            ipfsClientConfig.style.display = "block";
            pinataConfig.style.display = "none";
          }
        };

        // Event listener per il cambio di servizio IPFS
        document
          .getElementById("ipfs-service")
          .addEventListener("change", function () {
            toggleIpfsConfigForms(this.value);
          });

        // Event listener per il toggle di IPFS
        document
          .getElementById("ipfs-switch")
          .addEventListener("change", async function () {
            try {
              const response = await fetch("/api/ipfs/toggle", {
                method: "POST",
                headers: {
                  Authorization: `Bearer ${getAuthToken()}`,
                },
              });

              const data = await response.json();

              if (data.success) {
                // Aggiorna l'interfaccia con il nuovo stato
                updateIpfsStatus();
                logger.info(
                  `IPFS ${
                    data.config.enabled ? "attivato" : "disattivato"
                  } con successo`
                );
              } else {
                // Reimposta lo switch allo stato precedente in caso di errore
                this.checked = !this.checked;
                logger.error(`Errore nel toggle IPFS: ${data.error}`);
                alert(`Errore: ${data.error}`);
              }
            } catch (error) {
              // Reimposta lo switch allo stato precedente in caso di errore
              this.checked = !this.checked;
              logger.error(
                `Errore nella richiesta toggle IPFS: ${error.message}`
              );
              alert(`Errore di rete: ${error.message}`);
            }
          });

        // Salvataggio configurazione IPFS
        document
          .getElementById("save-ipfs-config")
          .addEventListener("click", async function () {
            const configStatus = document.getElementById("ipfs-config-status");
            configStatus.innerHTML =
              '<div class="info">Salvataggio configurazione...</div>';

            try {
              const service = document.getElementById("ipfs-service").value;
              const nodeUrl = document.getElementById("ipfs-node-url").value;
              const gateway = document.getElementById("ipfs-gateway").value;
              const pinataJwt = document.getElementById("pinata-jwt").value;

              const config = {
                service,
                nodeUrl,
                gateway,
              };

              if (service === "PINATA" && pinataJwt) {
                config.pinataJwt = pinataJwt;
              }

              const response = await fetch("/api/ipfs/config", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  Authorization: `Bearer ${getAuthToken()}`,
                },
                body: JSON.stringify(config),
              });

              const data = await response.json();

              if (data.success) {
                configStatus.innerHTML =
                  '<div class="success">Configurazione salvata con successo</div>';
                updateIpfsStatus();
                logger.info("Configurazione IPFS aggiornata con successo");
              } else {
                configStatus.innerHTML = `<div class="error">Errore: ${data.error}</div>`;
                logger.error(
                  `Errore nel salvataggio configurazione: ${data.error}`
                );
              }
            } catch (error) {
              configStatus.innerHTML = `<div class="error">Errore: ${error.message}</div>`;
              logger.error(`Errore nella richiesta: ${error.message}`);
            }
          });





        // Funzione per verificare lo stato del pin di un file IPFS
        const checkPinStatus = async (hash) => {
          try {
            // Verifica che ci sia l'autenticazione
            if (!(await checkAuth())) {
              logger.error(
                "Autenticazione richiesta per verificare lo stato del pin"
              );
              return;
            }

            const statusElement = document.getElementById(`pin-status-${hash}`);
            const pinButton = document.querySelector(
              `.pin-button[data-hash="${hash}"]`
            );
            const unpinButton = document.querySelector(
              `.unpin-button[data-hash="${hash}"]`
            );

            if (!statusElement || !pinButton || !unpinButton) {
              return;
            }

            statusElement.textContent = "Verifica pin...";
            statusElement.className = "pin-status";

            const response = await fetch(`/api/ipfs/pin-status/${hash}`, {
              headers: {
                Authorization: `Bearer ${getAuthToken()}`,
              },
            });

            const data = await response.json();

            if (data.success) {
              if (data.isPinned) {
                statusElement.textContent = "Pinned";
                statusElement.className = "pin-status pinned";
                pinButton.style.display = "none";
                unpinButton.style.display = "inline-block";
              } else {
                statusElement.textContent = "Not pinned";
                statusElement.className = "pin-status unpinned";
                pinButton.style.display = "inline-block";
                unpinButton.style.display = "none";
              }
            } else {
              statusElement.textContent = "Errore: " + data.error;
              statusElement.className = "pin-status unpinned";
              logger.error(`Errore verifica pin: ${data.error}`);
            }
          } catch (error) {
            logger.error(`Errore verifica pin: ${error.message}`);
            const statusElement = document.getElementById(`pin-status-${hash}`);
            if (statusElement) {
              statusElement.textContent = "Errore verifica pin";
              statusElement.className = "pin-status unpinned";
            }
          }
        };

        // Funzione per pinnare un file
        const pinFile = async (hash) => {
          try {
            if (!(await checkAuth())) {
              logger.error("Autenticazione richiesta per pinnare file");
              return;
            }

            const statusElement = document.getElementById(`pin-status-${hash}`);
            statusElement.textContent = "Pinning...";
            statusElement.className = "pin-status";

            const response = await fetch("/api/ipfs/pin", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${getAuthToken()}`,
              },
              body: JSON.stringify({ hash }),
            });

            const data = await response.json();

            if (data.success) {
              statusElement.textContent = "Pinned";
              statusElement.className = "pin-status pinned";
              document.querySelector(
                `.pin-button[data-hash="${hash}"]`
              ).style.display = "none";
              document.querySelector(
                `.unpin-button[data-hash="${hash}"]`
              ).style.display = "inline-block";
              logger.info(`File pinned with success: ${hash}`);
            } else {
              statusElement.textContent = "Errore: " + data.error;
              statusElement.className = "pin-status unpinned";
              logger.error(`Errore durante il pin: ${data.error}`);
            }
          } catch (error) {
            logger.error(`Errore durante il pin: ${error.message}`);
            const statusElement = document.getElementById(`pin-status-${hash}`);
            if (statusElement) {
              statusElement.textContent = "Errore pin";
              statusElement.className = "pin-status unpinned";
            }
          }
        };

        // Funzione per unpinnare un file
        const unpinFile = async (hash) => {
          try {
            if (!(await checkAuth())) {
              logger.error("Autenticazione richiesta per unpinnare file");
              return;
            }

            const statusElement = document.getElementById(`pin-status-${hash}`);
            statusElement.textContent = "Unpinning...";
            statusElement.className = "pin-status";

            const response = await fetch("/api/ipfs/unpin", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${getAuthToken()}`,
              },
              body: JSON.stringify({ hash }),
            });

            const data = await response.json();

            if (data.success) {
              statusElement.textContent = "Unpinned";
              statusElement.className = "pin-status unpinned";
              document.querySelector(
                `.pin-button[data-hash="${hash}"]`
              ).style.display = "inline-block";
              document.querySelector(
                `.unpin-button[data-hash="${hash}"]`
              ).style.display = "none";
              logger.info(`File unpinned with success: ${hash}`);
            } else {
              statusElement.textContent = "Errore: " + data.error;
              statusElement.className = "pin-status unpinned";
              logger.error(`Errore durante l'unpin: ${data.error}`);
            }
          } catch (error) {
            logger.error(`Errore durante l'unpin: ${error.message}`);
            const statusElement = document.getElementById(`pin-status-${hash}`);
            if (statusElement) {
              statusElement.textContent = "Errore unpin";
              statusElement.className = "pin-status unpinned";
            }
          }
        };



        // Add debug command handler - versione migliorata
        const handleDebugCommand = async () => {
          try {
            console.log("Debug command detected, collecting diagnostics...");

            // Check for MPC server
            const hasMpcServer = typeof window.__MPCServer !== "undefined";

            // Mostra stato debug nell'interfaccia
            showToast("Esecuzione diagnostica in corso...", "info");

            // Invia una richiesta POST al server
            const response = await fetch("/debug", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${getAuthToken()}`,
              },
              body: JSON.stringify({
                timestamp: Date.now(),
                clientInfo: {
                  userAgent: navigator.userAgent,
                  url: window.location.href,
                  screen: {
                    width: window.screen.width,
                    height: window.screen.height,
                  },
                },
              }),
            });

            // Esegui diagnostica lato cliente con MPC se disponibile
            if (hasMpcServer) {
              try {
                console.log(
                  "MPC server disponibile, raccolta diagnostica avanzata..."
                );

                // Raccogli screenshot e log
                await window.__MPCServer.call("takeScreenshot", {
                  random_string: "debug_command",
                });
                await window.__MPCServer.call("getConsoleLogs", {
                  random_string: "debug_command",
                });
                await window.__MPCServer.call("getConsoleErrors", {
                  random_string: "debug_command",
                });
                await window.__MPCServer.call("getNetworkLogs", {
                  random_string: "debug_command",
                });

                showToast("Diagnostica completa con screenshot", "success");
              } catch (mpcError) {
                console.error("Errore MPC:", mpcError);
                showToast("Errore nella diagnostica avanzata", "warning");
              }
            } else {
              console.log("MPC server non disponibile, solo diagnostica base");
            }

            // Mostra risultato server
            if (response.ok) {
              const result = await response.json();
              console.log("Risultato debug server:", result);
              showToast("Diagnostica completata con successo", "success");

              // Mostra i risultati nell'interfaccia
              const debugResult = document.createElement("div");
              debugResult.className = "card debug-result";
              debugResult.innerHTML = `
                <div class="card-header">
                  <h3 class="card-title">Risultati Diagnostica</h3>
                </div>
                <pre>${JSON.stringify(result, null, 2)}</pre>
              `;

              // Aggiungi alla prima posizione nel container
              const container = document.querySelector(".container");
              container.insertBefore(
                debugResult,
                container.firstChild.nextSibling
              );

              // Rimuovi il risultato dopo 60 secondi
              setTimeout(() => {
                debugResult.remove();
              }, 60000);
            } else {
              console.error("Errore nella richiesta debug al server");
              showToast("Errore nella diagnostica lato server", "error");
            }
          } catch (error) {
            console.error("Errore durante il comando debug:", error);
            showToast(
              "Errore durante la diagnostica: " + error.message,
              "error"
            );
          }
        };

        // Aggiungi pulsante dedicato nella barra principale "Debug"
        document.querySelector(".navbar .nav-links").innerHTML += `
          <a href="#" id="debug-command-btn" style="color: #ff3366;">Debug</a>
        `;

        // Aggiungi event listener per il pulsante di debug nella barra
        document
          .getElementById("debug-command-btn")
          .addEventListener("click", (e) => {
            e.preventDefault();
            
            // Toggle della visualizzazione dei log di debug
            const logContainer = document.getElementById("log-container");
            if (logContainer.style.display === "none") {
              logContainer.style.display = "block";
              // Esegui comando debug solo quando si mostra il pannello
              handleDebugCommand();
            } else {
              logContainer.style.display = "none";
            }
          });

        // Gestione controllo connessione IPFS
        document
          .getElementById("ipfs-check-connection")
          .addEventListener("click", async function () {
            const statusIndicator = document.getElementById("ipfs-status-indicator");
            const reconnectButton = document.getElementById("ipfs-reconnect");
            
            try {
              // Show checking status
              statusIndicator.className = "status-checking";
              statusIndicator.textContent = "Verifica in corso...";
              
              // Make API call to check connection health
              const response = await fetch("/api/ipfs/health-check", {
                headers: {
                  Authorization: `Bearer ${getAuthToken()}`,
                },
              });
              
              const data = await response.json();
              
              // Update status based on API response
              if (!data.enabled) {
                statusIndicator.className = "status-disabled";
                statusIndicator.textContent = "IPFS disabilitato";
                reconnectButton.style.display = "none";
              } else if (data.success) {
                statusIndicator.className = "status-connected";
                statusIndicator.textContent = "Connesso";
                reconnectButton.style.display = "none";
                showToast("Connessione IPFS verificata con successo", "success");
              } else {
                statusIndicator.className = "status-error";
                statusIndicator.textContent = "Errore di connessione";
                reconnectButton.style.display = "inline-block";
                showToast("Errore nella connessione IPFS", "error");
              }
              
              logger.info(`Stato connessione IPFS: ${data.message}`);
            } catch (error) {
              statusIndicator.className = "status-error";
              statusIndicator.textContent = "Errore di rete";
              reconnectButton.style.display = "inline-block";
              logger.error(`Errore verifica connessione IPFS: ${error.message}`);
              showToast(`Errore di rete: ${error.message}`, "error");
            }
          });
          
        // Gestione riconnessione IPFS
        document
          .getElementById("ipfs-reconnect")
          .addEventListener("click", async function () {
            const statusIndicator = document.getElementById("ipfs-status-indicator");
            
            try {
              // Show reconnecting status
              statusIndicator.className = "status-checking";
              statusIndicator.textContent = "Riconnessione in corso...";
              showLoading();
              
              // Make API call to reinitialize connection
              const response = await fetch("/api/ipfs/reinitialize", {
                method: "POST",
                headers: {
                  Authorization: `Bearer ${getAuthToken()}`,
                },
              });
              
              const data = await response.json();
              
              // Update status based on API response
              if (data.success) {
                statusIndicator.className = "status-connected";
                statusIndicator.textContent = "Connesso";
                this.style.display = "none";
                showToast("Connessione IPFS ripristinata con successo", "success");
                logger.success("Connessione IPFS ripristinata con successo");
                // Refresh configuration UI
                updateIpfsStatus();
              } else {
                statusIndicator.className = "status-error";
                statusIndicator.textContent = "Errore di riconnessione";
                showToast(`Impossibile ripristinare la connessione: ${data.message}`, "error");
                logger.error(`Errore riconnessione IPFS: ${data.message}`);
              }
            } catch (error) {
              statusIndicator.className = "status-error";
              statusIndicator.textContent = "Errore di rete";
              logger.error(`Errore riconnessione IPFS: ${error.message}`);
              showToast(`Errore di rete: ${error.message}`, "error");
            } finally {
              hideLoading();
            }
          });
          
        // Aggiorna IPFS status check all'avvio
        async function checkIpfsConnection() {
          const statusIndicator = document.getElementById("ipfs-status-indicator");
          const reconnectButton = document.getElementById("ipfs-reconnect");
          
          try {
            // Get IPFS status
            const response = await fetch("/api/ipfs/status", {
              headers: {
                Authorization: `Bearer ${getAuthToken()}`,
              },
            });
            
            if (!response.ok) {
              throw new Error(`HTTP error: ${response.status}`);
            }
            
            const data = await response.json();
            
            // Update UI based on status
            if (!data.isEnabled) {
              statusIndicator.className = "status-disabled";
              statusIndicator.textContent = "IPFS disabilitato";
              reconnectButton.style.display = "none";
              return;
            }
            
            // If enabled, check health
            try {
              const healthResponse = await fetch("/api/ipfs/health-check", {
                headers: {
                  Authorization: `Bearer ${getAuthToken()}`,
                },
              });
              
              const healthData = await healthResponse.json();
              
              if (healthData.success) {
                statusIndicator.className = "status-connected";
                statusIndicator.textContent = "Connesso";
                reconnectButton.style.display = "none";
              } else {
                statusIndicator.className = "status-error";
                statusIndicator.textContent = "Errore di connessione";
                reconnectButton.style.display = "inline-block";
              }
            } catch (healthError) {
              statusIndicator.className = "status-error";
              statusIndicator.textContent = "Errore di rete";
              reconnectButton.style.display = "inline-block";
            }
          } catch (error) {
            statusIndicator.className = "status-unknown";
            statusIndicator.textContent = "Stato sconosciuto";
            logger.error(`Errore status IPFS: ${error.message}`);
          }
        }
      });
    </script>
  </body>
</html>
