<!DOCTYPE html>
<html lang="en" data-theme="dark">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Shogun Relay Dashboard - React</title>
    
    <!-- Tailwind CSS via CDN with DaisyUI -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.12.10/dist/full.min.css" rel="stylesheet" type="text/css" />
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet" />
    
    <!-- React 18 -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
      body { 
        font-family: 'Inter', sans-serif; 
        margin: 0;
        padding: 0;
        background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%);
        min-height: 100vh;
      }
      
      /* Enhanced animations */
      .tab-content { 
        animation: slideInUp 0.4s cubic-bezier(0.4, 0, 0.2, 1); 
      }
      
      @keyframes slideInUp {
        from { 
          opacity: 0; 
          transform: translateY(30px) scale(0.95); 
        }
        to { 
          opacity: 1; 
          transform: translateY(0) scale(1); 
        }
      }
      
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
      }
      
      @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.05); }
      }
      
      @keyframes shimmer {
        0% { background-position: -200px 0; }
        100% { background-position: calc(200px + 100%) 0; }
      }
      
      /* Glassmorphism effects */
      .glass-card {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 16px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      }
      
      .glass-card-dark {
        background: rgba(0, 0, 0, 0.2);
        backdrop-filter: blur(15px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 20px;
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
      }
      
      /* Enhanced gradient backgrounds */
      .gradient-primary {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      }
      
      .gradient-success {
        background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
      }
      
      .gradient-warning {
        background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
      }
      
      .gradient-error {
        background: linear-gradient(135deg, #f87171 0%, #ef4444 100%);
      }
      
      .gradient-info {
        background: linear-gradient(135deg, #60a5fa 0%, #3b82f6 100%);
      }
      
      .gradient-purple {
        background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
      }
      
      /* Hover effects */
      .hover-lift {
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }
      
      .hover-lift:hover {
        transform: translateY(-8px) scale(1.02);
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4);
      }
      
      .hover-glow:hover {
        box-shadow: 0 0 30px rgba(102, 126, 234, 0.5);
      }
      
      /* Loading shimmer effect */
      .shimmer {
        background: linear-gradient(90deg, 
          rgba(255, 255, 255, 0.1) 0%, 
          rgba(255, 255, 255, 0.3) 50%, 
          rgba(255, 255, 255, 0.1) 100%);
        background-size: 200px 100%;
        animation: shimmer 1.5s infinite;
      }
      
      /* Custom scrollbar */
      ::-webkit-scrollbar {
        width: 8px;
      }
      
      ::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
      }
      
      ::-webkit-scrollbar-thumb {
        background: linear-gradient(135deg, #667eea, #764ba2);
        border-radius: 4px;
      }
      
      ::-webkit-scrollbar-thumb:hover {
        background: linear-gradient(135deg, #764ba2, #667eea);
      }
      
      /* Enhanced status indicators */
      .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        display: inline-block;
        margin-right: 8px;
        animation: pulse 2s infinite;
      }
      
      .status-online { background-color: #10b981; }
      .status-offline { background-color: #ef4444; }
      .status-warning { background-color: #f59e0b; }
      
      /* File type icons enhancement */
      .file-icon {
        font-size: 2rem;
        filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.2));
        transition: transform 0.3s ease;
      }
      
      .file-icon:hover {
        transform: scale(1.2) rotate(5deg);
      }
      
      /* Enhanced buttons */
      .btn-enhanced {
        position: relative;
        overflow: hidden;
        transition: all 0.3s ease;
      }
      
      .btn-enhanced::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        transition: left 0.5s;
      }
      
      .btn-enhanced:hover::before {
        left: 100%;
      }
      
      /* Fallback styling */
      .fallback-container {
        min-height: 100vh;
        background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%);
        color: white;
        padding: 20px;
        font-family: 'Inter', sans-serif;
      }
      
      .fallback-card {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 16px;
        padding: 20px;
        margin: 20px 0;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      }
      
      .fallback-button {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 12px 24px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        margin: 5px;
        transition: all 0.3s ease;
        font-weight: 600;
      }
      
      .fallback-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
      }
      
      /* Enhanced progress bars */
      .progress-enhanced {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(5px);
        border-radius: 10px;
        overflow: hidden;
        position: relative;
      }
      
      .progress-enhanced::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
        animation: shimmer 2s infinite;
      }
    </style>
  </head>
  
  <body>
    <div id="app">
      <!-- Enhanced loading indicator -->
      <div class="fallback-container">
        <div class="fallback-card">
          <h1>üöÄ Loading Shogun Relay Dashboard...</h1>
          <p>Initializing React components...</p>
          <div style="text-align: center; margin-top: 20px;">
            <div style="display: inline-block; width: 40px; height: 40px; border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; animation: spin 1s linear infinite;"></div>
          </div>
        </div>
      </div>
    </div>

    <style>
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      
      /* Tab content styling */
      .tab-content {
        min-height: 600px;
        display: block !important;
        visibility: visible !important;
        opacity: 1 !important;
      }
      
      /* Ensure all tab content elements are visible */
      .space-y-6 {
        display: block !important;
        visibility: visible !important;
      }
      
      .space-y-6 > * {
        margin-bottom: 1.5rem !important;
        display: block !important;
        visibility: visible !important;
      }
      
      /* Force container visibility */
      .tab-content * {
        visibility: visible !important;
        opacity: 1 !important;
      }
    </style>

    <script type="text/babel">
      console.log('üöÄ Shogun Relay Dashboard - React Version Starting...');
      console.log('React loaded:', typeof React !== 'undefined');
      console.log('ReactDOM loaded:', typeof ReactDOM !== 'undefined');
      console.log('Current location:', window.location.href);
      
      const { useState, useEffect } = React;

      // Enhanced toast system
      const toast = {
        success: (message) => showToast(message, 'success'),
        error: (message) => showToast(message, 'error'),
        info: (message) => showToast(message, 'info'),
        warning: (message) => showToast(message, 'warning')
      };

      function showToast(message, type = 'info') {
        const toastContainer = document.getElementById('toast-container') || createToastContainer();
        const toastEl = document.createElement('div');
        
        const typeClasses = {
          success: 'alert-success',
          error: 'alert-error', 
          info: 'alert-info',
          warning: 'alert-warning'
        };
        
        toastEl.className = `alert ${typeClasses[type] || 'alert-info'} shadow-lg mb-2`;
        toastEl.innerHTML = `<span>${message}</span>`;
        toastContainer.appendChild(toastEl);
        
        setTimeout(() => {
          if (toastEl.parentNode) {
            toastEl.remove();
          }
        }, 3000);
      }

      function createToastContainer() {
        const container = document.createElement('div');
        container.id = 'toast-container';
        container.className = 'toast toast-end fixed top-4 right-4 z-50';
        container.style.position = 'fixed';
        container.style.top = '1rem';
        container.style.right = '1rem';
        container.style.zIndex = '9999';
        document.body.appendChild(container);
        return container;
      }

      // Main Dashboard Component
      function Dashboard() {
        const [activeTab, setActiveTab] = useState("files");
        const [theme, setTheme] = useState("dark");
        const [fileStats, setFileStats] = useState({ count: 0, totalSize: 0 });
        const [dashboardStats, setDashboardStats] = useState({
          totalFiles: 0,
          todayFiles: 0,
          storage: { used: 0, total: 0, percentage: 0, remainingPercentage: 100 },
          sharedLinks: { total: 0, active: 0, exhausted: 0, expired: 0 }
        });
        const [serverStatus, setServerStatus] = useState({ status: "checking...", port: "8765" });
        const [realFiles, setRealFiles] = useState([]);
        const [relayStatus, setRelayStatus] = useState(null);
        const [ipfsConnectionStatus, setIpfsConnectionStatus] = useState({ status: "checking", message: "Checking IPFS..." });
        const [isLoading, setIsLoading] = useState(true);
        const [dataLoading, setDataLoading] = useState(false);
        const [uploadProgress, setUploadProgress] = useState({});
        const [uploadTarget, setUploadTarget] = useState("auto"); // "local", "ipfs", "auto"
        const [fileFilter, setFileFilter] = useState("all"); // "all", "local", "ipfs"
        const [gunStats, setGunStats] = useState({
          peers: { count: 0, time: 0 },
          nodes: { count: 0 },
          uptime: { time: 0 },
          memory: { heapTotal: 0 },
          dam: { in: { count: 0, done: 0 }, out: { count: 0, done: 0 } },
          cpu: { stack: 0 },
          block: 0
        });

        // File action functions
        const handleFileDownload = async (file) => {
          try {
            console.log('‚¨áÔ∏è Downloading file:', file.originalName);
            
            const authToken = window.localStorage.getItem('shogun_token') || 'shogun2025';
            let downloadUrl = null;
            let needsAuth = false;
            
            // Determine download URL based on file type
            if (file.ipfsHash && file.ipfsUrl) {
              // IPFS file - check if it's using local gateway
              if (file.ipfsUrl.includes('127.0.0.1') || file.ipfsUrl.includes('localhost') || file.ipfsUrl.includes('/gateway/ipfs/')) {
                // Local IPFS gateway - needs authentication
                downloadUrl = file.ipfsUrl;
                needsAuth = true;
                toast.info(`üåê Downloading from local IPFS gateway: ${file.originalName}`);
              } else {
                // External IPFS gateway - no auth needed
                downloadUrl = file.ipfsUrl;
                toast.info(`üåê Downloading from IPFS: ${file.originalName}`);
              }
            } else if (file.fileUrl) {
              // Local file with direct URL
              downloadUrl = file.fileUrl;
              needsAuth = true;
              toast.info(`üìÅ Downloading from local storage: ${file.originalName}`);
            } else if (file.id) {
              // Use file ID to construct download URL
              downloadUrl = `/uploads/${file.id}`;
              needsAuth = true;
              toast.info(`üìÅ Downloading: ${file.originalName}`);
            } else {
              throw new Error('No download URL available for this file');
            }
            
            if (needsAuth) {
              // Debug: log the authenticated download
              console.log('üîê Downloading with auth:', downloadUrl);
              
              // For authenticated downloads, use fetch to get the file with auth headers
              const response = await fetch(downloadUrl, {
                headers: {
                  'Authorization': `Bearer ${authToken}`
                }
              });
              
              if (!response.ok) {
                throw new Error(`Download failed: HTTP ${response.status}`);
              }
              
              // Get the file as blob
              const blob = await response.blob();
              
              // Create download link with blob URL
              const blobUrl = URL.createObjectURL(blob);
              const link = document.createElement('a');
              link.href = blobUrl;
              link.download = file.originalName || file.name || 'download';
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
              
              // Clean up blob URL
              setTimeout(() => URL.revokeObjectURL(blobUrl), 1000);
            } else {
              // For public downloads, use direct link
              const link = document.createElement('a');
              link.href = downloadUrl;
              link.download = file.originalName || file.name || 'download';
              link.target = '_blank';
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
            }
            
            toast.success(`‚úÖ Download started: ${file.originalName}`);
          } catch (error) {
            console.error('‚ùå Download error:', error);
            toast.error(`‚ùå Download failed: ${error.message}`);
          }
        };

        const handleFileDelete = async (file) => {
          try {
            const fileName = file.originalName || file.name || 'file';
            
            if (!confirm(`Are you sure you want to delete "${fileName}"?`)) {
              return;
            }
            
            console.log('üóëÔ∏è Deleting file:', fileName, 'ID:', file.id);
            setDataLoading(true);
            
            const authToken = window.localStorage.getItem('shogun_token') || 'shogun2025';
            let deleteUrl = null;
            
            // Determine delete endpoint based on file type
            if (file.storageType === 'ipfs-independent' || (file.independent && file.ipfsHash)) {
              // IPFS independent file - try with file ID first, then hash
              const fileIdentifier = file.id || file.ipfsHash;
              deleteUrl = `/api/ipfs/files/${fileIdentifier}`;
              toast.info(`üåê Deleting IPFS file: ${fileName}`);
              console.log(`üåê Using IPFS delete endpoint with identifier: ${fileIdentifier}`);
            } else if (file.id) {
              // Local file or local file with IPFS
              deleteUrl = `/api/files/${file.id}`;
              toast.info(`üìÅ Deleting local file: ${fileName}`);
              console.log(`üìÅ Using regular delete endpoint with ID: ${file.id}`);
            } else {
              throw new Error('Cannot determine delete endpoint for this file');
            }
            
            let response = await fetch(deleteUrl, {
              method: 'DELETE',
              headers: {
                'Authorization': `Bearer ${authToken}`
              }
            });
            
            // If IPFS delete failed and we have a file ID, try regular delete endpoint as fallback
            if (!response.ok && deleteUrl.includes('/api/ipfs/files/') && file.id) {
              console.log(`üîÑ IPFS delete failed (${response.status}), trying regular delete endpoint for file ID: ${file.id}`);
              toast.info(`üîÑ Trying alternative delete method...`);
              
              const fallbackUrl = `/api/files/${file.id}`;
              response = await fetch(fallbackUrl, {
                method: 'DELETE',
                headers: {
                  'Authorization': `Bearer ${authToken}`
                }
              });
              
              // If both methods failed with 404, the file is already gone
              if (!response.ok && response.status === 404) {
                console.log(`üîÑ Both delete methods returned 404, file was already deleted: ${fileName}`);
                toast.warning(`‚ö†Ô∏è File was already deleted: ${fileName}`);
                // Refresh the file list to remove the stale entry
                await loadRealData();
                return; // Exit early since we handled the case
              }
            }
            
            if (response.ok) {
              const result = await response.json();
              if (result.success) {
                toast.success(`‚úÖ File deleted successfully: ${fileName}`);
                // Refresh the file list
                await loadRealData();
              } else {
                throw new Error(result.error || 'Delete failed');
              }
            } else if (response.status === 404) {
              // File not found - it was probably already deleted
              console.log(`üîÑ File not found (404), removing from display: ${fileName}`);
              toast.warning(`‚ö†Ô∏è File was already deleted: ${fileName}`);
              // Refresh the file list to remove the stale entry
              await loadRealData();
            } else {
              const error = await response.json().catch(() => ({ error: `HTTP ${response.status}` }));
              throw new Error(error.error || `HTTP ${response.status}`);
            }
          } catch (error) {
            console.error('‚ùå Delete error:', error);
            toast.error(`‚ùå Delete failed: ${error.message}`);
          } finally {
            setDataLoading(false);
          }
        };

        const handleFileView = async (file) => {
          try {
            console.log('üëÅÔ∏è Viewing file:', file.originalName);
            
            const authToken = window.localStorage.getItem('shogun_token') || 'shogun2025';
            let viewUrl = null;
            
            // Determine view URL based on file type
            if (file.ipfsHash && file.ipfsUrl) {
              // IPFS file - use authenticated URL for local gateway
              if (file.ipfsUrl.includes('127.0.0.1') || file.ipfsUrl.includes('localhost') || file.ipfsUrl.includes('/gateway/ipfs/')) {
                // Local IPFS gateway - add auth token as query parameter
                viewUrl = `${file.ipfsUrl}?token=${authToken}`;
              } else {
                // External IPFS gateway
                viewUrl = file.ipfsUrl;
              }
              toast.info(`üëÅÔ∏è Opening IPFS file: ${file.originalName}`);
            } else if (file.fileUrl) {
              // Local file with direct URL
              viewUrl = `${file.fileUrl}?token=${authToken}`;
              toast.info(`üëÅÔ∏è Opening local file: ${file.originalName}`);
            } else if (file.id) {
              // Use file ID to construct view URL
              viewUrl = `/uploads/${file.id}?token=${authToken}`;
              toast.info(`üëÅÔ∏è Opening file: ${file.originalName}`);
            } else {
              throw new Error('No view URL available for this file');
            }
            
            // Debug: log the URL being opened
            console.log('üîó Opening URL with auth:', viewUrl);
            
            // Open in new tab
            window.open(viewUrl, '_blank');
            
          } catch (error) {
            console.error('‚ùå View error:', error);
            toast.error(`‚ùå View failed: ${error.message}`);
          }
        };

        const handleFileInfo = (file) => {
          const fileName = file.originalName || file.name || 'Unknown';
          const fileSize = formatFileSize(file.size || 0);
          const fileType = file.mimetype || file.mimeType || 'Unknown';
          const storageType = file.storageType || 'Unknown';
          const uploadDate = file.timestamp || file.uploadedAt ? 
            new Date(file.timestamp || file.uploadedAt).toLocaleString() : 'Unknown';
          
          let infoMessage = `üìÑ File: ${fileName}\n`;
          infoMessage += `üìè Size: ${fileSize}\n`;
          infoMessage += `üè∑Ô∏è Type: ${fileType}\n`;
          infoMessage += `üíæ Storage: ${storageType}\n`;
          infoMessage += `üìÖ Uploaded: ${uploadDate}`;
          
          if (file.ipfsHash) {
            infoMessage += `\nüåê IPFS Hash: ${file.ipfsHash}`;
            if (file.ipfsUrl) {
              infoMessage += `\nüîó IPFS URL: ${file.ipfsUrl}`;
            }
          }
          
          if (file.id) {
            infoMessage += `\nüÜî ID: ${file.id}`;
          }
          
          alert(infoMessage);
          console.log('‚ÑπÔ∏è File info:', file);
        };

        const handleFileShare = async (file) => {
          try {
            console.log('üîó Creating shareable link for:', file.originalName);
            
            const authToken = window.localStorage.getItem('shogun_token') || 'shogun2025';
            
            // Show modal for share options
            const password = prompt('üîí Enter password for the link (optional, leave empty for no password):');
            const expiresIn = prompt('‚è∞ Link expires in hours (default: 24, 0 = never expires):', '24');
            const maxDownloads = prompt('üì• Maximum downloads (default: 10):', '10');
            
            const shareData = {
              fileId: file.id,
              password: password || '',
              expiresIn: (parseInt(expiresIn) || 24) * 3600, // Convert hours to seconds
              maxDownloads: parseInt(maxDownloads) || 10,
              description: `Shared file: ${file.originalName || file.name}`
            };
            
            toast.info('üîó Creating shareable link...');
            
            const response = await fetch('/api/files/create-share-link', {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${authToken}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(shareData)
            });
            
            if (response.ok) {
              const result = await response.json();
              if (result.success) {
                const shareUrl = result.shareData.shareUrl || `${window.location.origin}/api/files/share/${result.shareData.token}`;
                
                // Copy to clipboard
                try {
                  await navigator.clipboard.writeText(shareUrl);
                  toast.success(`üîó Shareable link created and copied to clipboard!`);
                } catch (clipboardError) {
                  toast.success(`üîó Shareable link created!`);
                }
                
                // Show the link in a modal-like alert
                const fileType = file.ipfsHash ? 'üåê IPFS File' : 'üìÅ Local File';
                const linkInfo = `üîó Shareable Link Created!\n\n` +
                  `üìÑ File: ${file.originalName || file.name}\n` +
                  `üìÇ Type: ${fileType}\n` +
                  `üîó Link: ${shareUrl}\n` +
                  `üîí Password: ${password ? 'Yes' : 'No'}\n` +
                  `‚è∞ Expires: ${shareData.expiresIn > 0 ? `${shareData.expiresIn} hours` : 'Never'}\n` +
                  `üì• Max Downloads: ${shareData.maxDownloads}\n\n` +
                  `Link has been copied to clipboard!`;
                
                alert(linkInfo);
                
                console.log('üîó Share link created:', result);
              } else {
                throw new Error(result.error || 'Failed to create share link');
              }
            } else {
              const error = await response.json();
              throw new Error(error.error || `HTTP ${response.status}`);
            }
          } catch (error) {
            console.error('‚ùå Share link creation error:', error);
            toast.error(`‚ùå Failed to create share link: ${error.message}`);
          }
        };

        // Function to handle real file upload
                const handleFileUpload = async (event) => {
          const files = Array.from(event.target.files);
          if (files.length === 0) return;
          
          console.log('üì§ Starting real file upload:', files.map(f => f.name));
          setDataLoading(true);
          
          // Check IPFS status and user preference
          let ipfsAvailable = false;
          let shouldUseIpfs = false;
          
          try {
            const ipfsStatusResponse = await fetch('/api/ipfs/status', {
              headers: {
                'Authorization': `Bearer ${window.localStorage.getItem('shogun_token') || 'shogun2025'}`
              }
            });
            
            if (ipfsStatusResponse.ok) {
              const ipfsStatus = await ipfsStatusResponse.json();
              ipfsAvailable = ipfsStatus.success && ipfsStatus.status?.enabled === true;
              console.log(`üåê IPFS status check: ${ipfsAvailable ? 'Available' : 'Not available'}`);
            }
          } catch (error) {
            console.warn('‚ö†Ô∏è Could not check IPFS status:', error);
          }
          
          // Determine upload strategy based on user choice and IPFS availability
          if (uploadTarget === "local") {
            shouldUseIpfs = false;
            toast.info('üìÅ Uploading to local storage (user choice)');
          } else if (uploadTarget === "ipfs") {
            if (ipfsAvailable) {
              shouldUseIpfs = true;
              toast.info('üåê Uploading to IPFS network (user choice)');
            } else {
              toast.error('‚ùå IPFS not available! Cannot upload to IPFS. Please choose local storage.');
              setDataLoading(false);
              return;
            }
          } else { // uploadTarget === "auto"
            shouldUseIpfs = ipfsAvailable;
            if (ipfsAvailable) {
              toast.info('üåê Auto-mode: Uploading to IPFS network');
            } else {
              toast.info('üìÅ Auto-mode: IPFS not available, uploading to local storage');
            }
          }
          
          try {
            const uploadPromises = files.map(async (file, index) => {
              const formData = new FormData();
              formData.append('file', file);
              formData.append('customName', file.name);

              // Track individual file progress
              const fileId = `${file.name}_${index}`;
              setUploadProgress(prev => ({ ...prev, [fileId]: 0 }));

              console.log(`üì§ Uploading file: ${file.name} (${formatFileSize(file.size)})`);
              
              try {
                let response;
                
                if (shouldUseIpfs) {
                  // Upload to IPFS
                  console.log(`üåê Uploading ${file.name} to IPFS`);
                  response = await fetch('/api/ipfs/upload', {
                    method: 'POST',
                    headers: {
                      'Authorization': `Bearer ${window.localStorage.getItem('shogun_token') || 'shogun2025'}`
                    },
                    body: formData
                  });
                } else {
                  // Upload to local storage
                  console.log(`üìÅ Uploading ${file.name} to local storage`);
                  response = await fetch('/api/files/upload', {
                    method: 'POST',
                    headers: {
                      'Authorization': `Bearer ${window.localStorage.getItem('shogun_token') || 'shogun2025'}`
                    },
                    body: formData
                  });
                }

                if (response.ok) {
                  const result = await response.json();
                  console.log(`‚úÖ File uploaded successfully:`, result);
                  
                  setUploadProgress(prev => ({ ...prev, [fileId]: 100 }));
                  
                  // Show appropriate success message based on upload type
                  if (result.ipfsHash) {
                    toast.success(`‚úÖ ${file.name} uploaded to IPFS!`);
                  } else if (result.fileUrl || result.path) {
                    toast.success(`‚úÖ ${file.name} uploaded to local storage!`);
                  } else {
                    toast.success(`‚úÖ ${file.name} uploaded successfully!`);
                  }
                  
                  // Store uploaded file info in browser storage as fallback
                  if (result.ipfsHash) {
                    try {
                      const recentUploads = JSON.parse(localStorage.getItem('recent_ipfs_uploads') || '[]');
                      const uploadInfo = {
                        ipfsHash: result.ipfsHash,
                        originalName: file.name,
                        name: file.name,
                        size: file.size,
                        mimetype: file.type,
                        ipfsUrl: result.ipfsUrl,
                        timestamp: Date.now(),
                        uploadedAt: Date.now()
                      };
                      
                      // Add to recent uploads (keep last 50)
                      recentUploads.unshift(uploadInfo);
                      const limitedUploads = recentUploads.slice(0, 50);
                      localStorage.setItem('recent_ipfs_uploads', JSON.stringify(limitedUploads));
                      
                      console.log(`üíæ Saved upload info to browser storage:`, uploadInfo);
                    } catch (storageError) {
                      console.warn('‚ö†Ô∏è Failed to save upload to browser storage:', storageError);
                    }
                  }
                  
                  return result;
                } else {
                  const error = await response.json();
                  console.error(`‚ùå Upload failed for ${file.name}:`, error);
                  toast.error(`‚ùå Failed to upload ${file.name}: ${error.message || 'Unknown error'}`);
                  throw new Error(error.message || 'Upload failed');
                }
              } catch (fileError) {
                console.error(`‚ùå Error uploading ${file.name}:`, fileError);
                toast.error(`‚ùå Error uploading ${file.name}: ${fileError.message}`);
                setUploadProgress(prev => ({ ...prev, [fileId]: -1 })); // Mark as failed
                throw fileError;
              }
            });

            // Wait for all uploads to complete
            const results = await Promise.allSettled(uploadPromises);
            
            const successful = results.filter(r => r.status === 'fulfilled').length;
            const failed = results.filter(r => r.status === 'rejected').length;
            
            if (successful > 0) {
              toast.success(`üéâ ${successful} file(s) uploaded successfully!`);
              // Refresh the files list to show new uploads
              await loadRealData();
            }
            
            if (failed > 0) {
              toast.warning(`‚ö†Ô∏è ${failed} file(s) failed to upload`);
            }

            // Clear upload progress after a delay
            setTimeout(() => {
              setUploadProgress({});
            }, 3000);

          } catch (error) {
            console.error('‚ùå Upload process error:', error);
            toast.error('‚ùå Upload failed: ' + error.message);
          } finally {
            setDataLoading(false);
            // Clear the file input
            event.target.value = '';
          }
        };

        // Drag & Drop handlers
        const handleDrop = (event) => {
          event.preventDefault();
          event.stopPropagation();
          
          const files = Array.from(event.dataTransfer.files);
          if (files.length > 0) {
            console.log('üìÅ Files dropped:', files.map(f => f.name));
            // Create an event object to handle the file upload
            const uploadEvent = { target: { files: files, value: '' } };
            handleFileUpload(uploadEvent);
          }
        };

        const handleDragOver = (event) => {
          event.preventDefault();
          event.stopPropagation();
        };

        const handleDragEnter = (event) => {
          event.preventDefault();
          event.stopPropagation();
        };

        const handleDragLeave = (event) => {
          event.preventDefault();
          event.stopPropagation();
        };

        // Function to validate file existence and remove stale entries
        const validateFileExistence = async (files, authToken) => {
          if (!files || files.length === 0) return files;
          
          console.log(`üîç Validating existence of ${files.length} files...`);
          const validFiles = [];
          let removedCount = 0;
          
          // Only validate a sample of files to avoid overwhelming the server
          const maxValidationChecks = 10;
          const filesToCheck = files.slice(0, maxValidationChecks);
          const remainingFiles = files.slice(maxValidationChecks);
          
          for (const file of filesToCheck) {
            try {
              // Quick check if file exists by trying to get its info
              const checkUrl = file.storageType === 'ipfs-independent' 
                ? `/api/ipfs/files/${file.id || file.ipfsHash}`
                : `/api/files/${file.id}`;
              
              const response = await fetch(checkUrl, {
                method: 'HEAD', // Use HEAD to avoid downloading file content
                headers: { 'Authorization': `Bearer ${authToken}` }
              });
              
              if (response.ok || response.status === 405) { // 405 = Method Not Allowed (HEAD not supported, but file exists)
                validFiles.push(file);
              } else if (response.status === 404) {
                console.log(`üóëÔ∏è Removing stale file entry: ${file.originalName || file.name} (${file.id})`);
                removedCount++;
              } else {
                // For other errors, keep the file (might be temporary server issue)
                validFiles.push(file);
              }
            } catch (error) {
              // On network errors, keep the file
              validFiles.push(file);
            }
          }
          
          // Add remaining files without validation to avoid performance issues
          validFiles.push(...remainingFiles);
          
          if (removedCount > 0) {
            console.log(`üßπ Removed ${removedCount} stale file entries`);
            toast.info(`üßπ Cleaned up ${removedCount} stale file entries`);
          }
          
          return validFiles;
        };

        // Function to load Gun statistics
        const loadGunStats = async () => {
          try {
            console.log('üìä Loading Gun statistics...');
            const response = await fetch('/gun/stats.radata', {
              method: 'GET',
              mode: 'cors'
            });
            
            if (response.ok) {
              const data = await response.json();
              console.log('üìä Gun stats loaded:', data);
              
              setGunStats({
                peers: {
                  count: data.peers?.count || 0,
                  time: data.peers?.time || 0
                },
                nodes: {
                  count: data.node?.count || 0
                },
                uptime: {
                  time: data.up?.time || 0
                },
                memory: {
                  heapTotal: data.memory?.heapTotal || 0
                },
                dam: {
                  in: {
                    count: data.dam?.in?.count || 0,
                    done: data.dam?.in?.done || 0
                  },
                  out: {
                    count: data.dam?.out?.count || 0,
                    done: data.dam?.out?.done || 0
                  }
                },
                cpu: {
                  stack: data.cpu?.stack || 0
                },
                block: data.block || 0
              });
            } else {
              console.warn('‚ö†Ô∏è Gun stats endpoint not available');
            }
          } catch (error) {
            console.warn('‚ö†Ô∏è Error loading Gun stats:', error);
          }
        };

        // Function to load combined files (local + IPFS independent)
        const loadRealData = async () => {
          console.log('üîÑ Loading combined data from APIs (local + IPFS)...');
          setDataLoading(true);
          
          try {
            const authToken = window.localStorage.getItem('shogun_token') || 'shogun2025';
            
            // Load local files and IPFS independent files in parallel with better error handling
            const [localFilesResponse, ipfsFilesResponse] = await Promise.allSettled([
              fetch('/api/files/all', {
                headers: { 'Authorization': `Bearer ${authToken}` }
              }),
              fetch('/api/ipfs/files', {
                headers: { 'Authorization': `Bearer ${authToken}` }
              })
            ]);
            
            // Process local files
            let localFiles = [];
            if (localFilesResponse.status === 'fulfilled' && localFilesResponse.value.ok) {
              try {
                const localData = await localFilesResponse.value.json();
                console.log('üìÅ Local files loaded:', localData);
                if (localData.success && localData.files) {
                  localFiles = localData.files;
                }
              } catch (parseError) {
                console.warn('‚ö†Ô∏è Error parsing local files response:', parseError);
              }
            } else {
              console.warn('‚ö†Ô∏è Local files API not available:', localFilesResponse.status === 'fulfilled' ? localFilesResponse.value.status : 'fetch failed');
            }
            
            // Process IPFS independent files with enhanced error handling
            let ipfsFiles = [];
            if (ipfsFilesResponse.status === 'fulfilled' && ipfsFilesResponse.value.ok) {
              try {
                const ipfsData = await ipfsFilesResponse.value.json();
                console.log('üåê IPFS independent files loaded:', ipfsData);
                if (ipfsData.success && ipfsData.files) {
                  ipfsFiles = ipfsData.files;
                }
              } catch (parseError) {
                console.warn('‚ö†Ô∏è Error parsing IPFS files response:', parseError);
              }
            } else {
              const reason = ipfsFilesResponse.status === 'fulfilled' 
                ? `HTTP ${ipfsFilesResponse.value.status}` 
                : 'fetch failed - endpoint may not exist';
              console.warn('‚ö†Ô∏è IPFS files API not available:', reason);
              
              // This is expected if the server doesn't have the /api/ipfs/files endpoint
              if (ipfsFilesResponse.status === 'rejected' || 
                  (ipfsFilesResponse.status === 'fulfilled' && ipfsFilesResponse.value.status === 404)) {
                console.info('‚ÑπÔ∏è IPFS independent files endpoint not implemented - this is normal for some servers');
              }
            }
            
            // If IPFS endpoint failed, try to recover recently uploaded files from browser storage
            if (ipfsFiles.length === 0) {
              try {
                const recentUploads = JSON.parse(localStorage.getItem('recent_ipfs_uploads') || '[]');
                const recentValidUploads = recentUploads.filter(upload => 
                  upload.ipfsHash && 
                  upload.timestamp && 
                  (Date.now() - upload.timestamp < 24 * 60 * 60 * 1000) // Last 24 hours
                );
                
                if (recentValidUploads.length > 0) {
                  console.log(`üîÑ Recovered ${recentValidUploads.length} recent IPFS uploads from browser storage`);
                  ipfsFiles = recentValidUploads.map(upload => ({
                    id: upload.ipfsHash,
                    originalName: upload.originalName || upload.name,
                    name: upload.originalName || upload.name,
                    size: upload.size || 0,
                    mimetype: upload.mimetype || 'application/octet-stream',
                    ipfsHash: upload.ipfsHash,
                    ipfsUrl: upload.ipfsUrl,
                    timestamp: upload.timestamp,
                    uploadedAt: upload.timestamp,
                    storageType: 'ipfs-independent',
                    source: 'ipfs-recovered'
                  }));
                  
                  toast.info(`üîÑ Recovered ${ipfsFiles.length} recent uploads from cache`);
                }
              } catch (storageError) {
                console.warn('‚ö†Ô∏è Error reading recent uploads from storage:', storageError);
              }
            }
            
            // Combine files from different sources
            const seenIds = new Set();
            const combinedFiles = [];
            
            // Process local files with proper storageType assignment
            localFiles.forEach(file => {
              if (!file || !file.id || seenIds.has(file.id)) {
                return;
              }
              
              // Determine correct storage type for local files
              let storageType = 'local-only';
              if (file.ipfsHash) {
                // Local file that has been uploaded to IPFS
                storageType = 'local-with-ipfs';
              }
              
              const processedFile = {
                ...file,
                storageType,
                source: 'local',
                // Ensure consistent naming
                originalName: file.originalName || file.name,
                mimetype: file.mimetype || file.mimeType
              };
              
              combinedFiles.push(processedFile);
              seenIds.add(file.id);
            });
            
            // Process IPFS independent files
            ipfsFiles.forEach(file => {
              if (!file || !file.id || seenIds.has(file.id)) {
                return;
              }
              
              const processedFile = {
                ...file,
                storageType: 'ipfs-independent',
                source: 'ipfs',
                // Ensure consistent properties
                originalName: file.originalName || file.name,
                mimetype: file.mimeType || file.mimetype,
                // Mark as independent for clarity
                independent: true,
                uploadType: file.uploadType || 'ipfs-direct'
              };
              
              combinedFiles.push(processedFile);
              seenIds.add(file.id);
            });
            
            // Sort files by timestamp (newest first)
            combinedFiles.sort((a, b) => {
              const aTime = parseInt(a.timestamp || a.uploadedAt || 0);
              const bTime = parseInt(b.timestamp || b.uploadedAt || 0);
              return bTime - aTime;
            });
            
            console.log(`üîÑ Combined files result:`);
            console.log(`- Local files: ${localFiles.length}`);
            console.log(`- IPFS files: ${ipfsFiles.length}`);
            console.log(`- Combined total: ${combinedFiles.length}`);
            
            // Validate files and remove any that no longer exist (optional cleanup)
            const validatedFiles = await validateFileExistence(combinedFiles, authToken);
            
            // Update state with validated files
            setRealFiles(validatedFiles);
            
            // Calculate real stats
            const totalSize = validatedFiles.reduce((sum, file) => sum + (file.size || 0), 0);
            setFileStats({
              count: validatedFiles.length,
              totalSize: totalSize
            });
            
            // Load dashboard statistics
            try {
              const statsResponse = await fetch('/api/files/stats', {
                headers: { 'Authorization': `Bearer ${authToken}` }
              });
              
              if (statsResponse.ok) {
                const statsData = await statsResponse.json();
                if (statsData.success && statsData.stats) {
                  setDashboardStats(statsData.stats);
                  console.log('üìä Dashboard stats loaded:', statsData.stats);
                }
              }
            } catch (statsError) {
              console.warn('‚ö†Ô∏è Failed to load dashboard stats:', statsError);
            }
            
            // Log file categorization for debugging
            const typeGroups = combinedFiles.reduce((acc, f) => {
              acc[f.storageType] = (acc[f.storageType] || 0) + 1;
              return acc;
            }, {});
            console.log('üìä File breakdown by storage type:', typeGroups);
            
            // Show appropriate success message
            if (combinedFiles.length > 0) {
              toast.success(`üìÅ Loaded ${combinedFiles.length} files (${localFiles.length} local + ${ipfsFiles.length} IPFS)`);
            } else if (localFiles.length === 0 && ipfsFiles.length === 0) {
              // Check if we just uploaded a file but it's not showing up
              const hasRecentUpload = Object.keys(uploadProgress).length > 0 || 
                                     localStorage.getItem('recent_ipfs_uploads') !== null;
              
              if (hasRecentUpload) {
                toast.warning('üìÅ Files uploaded but not visible - server may need IPFS files endpoint');
                console.warn('üîç Files were uploaded successfully but are not appearing in the file list. This usually means:');
                console.warn('1. The /api/ipfs/files endpoint is not implemented on this server');
                console.warn('2. Files are stored but not indexed properly');
                console.warn('3. There may be a delay in file processing');
              } else {
                toast.info('üìÇ No files found - try uploading some files!');
              }
            }
            
            // Load relay status
            try {
              const statusResponse = await fetch('/api/relay/status', {
                headers: {
                  'Authorization': `Bearer ${authToken}`,
                  'Content-Type': 'application/json',
                  token: authToken
                }
              });
              
              if (statusResponse.ok) {
                const statusData = await statusResponse.json();
                console.log('üîå Relay status loaded:', statusData);
                setRelayStatus(statusData);
                setServerStatus({ 
                  status: statusData.success ? "online" : "offline", 
                  port: "8765" 
                });
              } else if (statusResponse.status === 503) {
                // Handle 503 when onchain membership is disabled - this is expected
                const errorData = await statusResponse.json();
                console.log('‚ö†Ô∏è Relay services not available (onchain membership disabled):', errorData);
                setRelayStatus({
                  success: false,
                  message: 'Relay services disabled',
                  config: errorData.data?.config || { enabled: false }
                });
                setServerStatus({ 
                  status: "local-mode", 
                  port: "8765",
                  message: "Running in local mode (onchain features disabled)"
                });
              } else {
                console.warn('‚ö†Ô∏è Relay status API returned error:', statusResponse.status);
                setServerStatus({ status: "error", port: "8765" });
              }
            } catch (error) {
              console.warn('‚ö†Ô∏è Relay status API not available:', error);
              setServerStatus({ status: "offline", port: "8765" });
            }
            
            // Load IPFS status separately
            try {
              const ipfsStatusResponse = await fetch('/api/ipfs/status', {
                headers: {
                  'Authorization': `Bearer ${authToken}`
                }
              });
              
              if (ipfsStatusResponse.ok) {
                const ipfsData = await ipfsStatusResponse.json();
                console.log('üåê IPFS status loaded:', ipfsData);
                
                if (ipfsData.success && ipfsData.status?.enabled) {
                  setIpfsConnectionStatus({ 
                    status: 'connected', 
                    message: `${ipfsData.status.service || 'IPFS'} Active`,
                    service: ipfsData.status.service,
                    gateway: ipfsData.status.gateway
                  });
                } else {
                  setIpfsConnectionStatus({ 
                    status: 'disabled', 
                    message: 'IPFS Disabled',
                    service: ipfsData.status?.service || 'Unknown'
                  });
                }
              } else {
                console.warn('‚ö†Ô∏è IPFS status API returned error:', ipfsStatusResponse.status);
                setIpfsConnectionStatus({ 
                  status: 'error', 
                  message: 'IPFS API Error' 
                });
              }
            } catch (error) {
              console.warn('‚ö†Ô∏è IPFS status API not available:', error);
              setIpfsConnectionStatus({ 
                status: 'error', 
                message: 'IPFS Unavailable' 
              });
            }
            
          } catch (error) {
            console.error('‚ùå Error loading combined data:', error);
            toast.error('Failed to load files: ' + error.message);
            setRealFiles([]);
            setFileStats({ count: 0, totalSize: 0 });
          } finally {
            setDataLoading(false);
          }
        };

        useEffect(() => {
          console.log('üîç Dashboard component mounted. Initial activeTab:', activeTab);
          
          // Initialize dashboard and load real data
          const initializeDashboard = async () => {
            setIsLoading(false);
            toast.success('üéâ Dashboard loaded successfully!');
            console.log('üîç Loading complete. Current activeTab:', activeTab);
            
            // Load real data from APIs
            await loadRealData();
            await loadGunStats();
          };
          
          // Small delay for UI then load real data
          setTimeout(initializeDashboard, 500);
          
          // Set up periodic Gun stats updates
          const gunStatsInterval = setInterval(loadGunStats, 5000); // Every 5 seconds
          
          return () => {
            clearInterval(gunStatsInterval);
          };
        }, []);
        
        useEffect(() => {
          console.log('üîç ActiveTab changed to:', activeTab);
        }, [activeTab]);

        const toggleTheme = () => {
          const newTheme = theme === "dark" ? "light" : "dark";
          setTheme(newTheme);
          document.documentElement.setAttribute("data-theme", newTheme);
          toast.info(`Theme switched to ${newTheme} mode`);
        };

        const formatFileSize = (bytes) => {
          if (bytes === 0) return "0 Bytes";
          const k = 1024;
          const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
          const i = Math.floor(Math.log(bytes) / Math.log(k));
          return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
        };

        if (isLoading) {
          return (
            <div className="min-h-screen bg-base-100 flex items-center justify-center">
              <div className="text-center">
                <div className="loading loading-spinner loading-lg text-primary mb-4"></div>
                <h2 className="text-2xl font-bold">üöÄ Initializing Dashboard</h2>
                <p className="text-base-content/70">Loading Shogun Relay Dashboard...</p>
              </div>
            </div>
          );
        }

        return (
          <div className="min-h-screen bg-base-100">
            {/* Header */}
            <header className="navbar bg-base-200 shadow-lg px-4 lg:px-6">
              <div className="navbar-start">
                <h1 className="btn btn-ghost text-xl font-bold">ü•∑ Shogun Relay</h1>
              </div>
              <div className="navbar-center hidden lg:flex">
                <div className="badge badge-success">React ‚úÖ</div>
              </div>
              <div className="navbar-end">
                <button onClick={toggleTheme} className="btn btn-ghost btn-circle">
                  {theme === "dark" ? "üåû" : "üåô"}
                </button>
                <div className="flex items-center gap-3">
                  <div className="badge badge-success">Online</div>
                  <div className="text-sm text-base-content/70">Port: 8765</div>
                </div>
              </div>
            </header>

            <main className="container mx-auto px-4 py-6 max-w-7xl">
              {/* Enhanced Header */}
              <div className="glass-card-dark rounded-3xl p-8 mb-8 relative overflow-hidden border border-white/20">
                <div className="absolute top-0 left-0 w-full h-full bg-gradient-to-br from-blue-500/10 via-purple-500/10 to-pink-500/10"></div>
                <div className="absolute top-4 right-4 w-32 h-32 bg-white/5 rounded-full -translate-y-8 translate-x-8"></div>
                <div className="absolute bottom-4 left-4 w-24 h-24 bg-white/5 rounded-full translate-y-8 -translate-x-8"></div>
                <div className="relative z-10">
                  <div className="flex items-center gap-4 mb-4">
                    <div className="text-6xl file-icon">ü•∑</div>
                    <div>
                      <h1 className="text-5xl font-black mb-2 bg-gradient-to-r from-blue-400 via-purple-400 to-pink-400 bg-clip-text text-transparent drop-shadow-lg">
                        Shogun Relay Dashboard
                      </h1>
                      <p className="text-xl text-white/80 font-medium">Decentralized file storage and relay management</p>
                    </div>
                  </div>
                  <div className="flex flex-wrap items-center gap-3">
                    <div className="badge badge-lg gradient-primary text-white font-bold border-0 px-4 py-2">
                      <span className="file-icon text-lg mr-2">üîí</span>
                      Decentralized Storage
                    </div>
                    <div className="badge badge-lg gradient-success text-white font-bold border-0 px-4 py-2">
                      <span className="file-icon text-lg mr-2">üåê</span>
                      IPFS Integration
                    </div>
                    <div className="badge badge-lg gradient-info text-white font-bold border-0 px-4 py-2">
                      <span className="file-icon text-lg mr-2">‚ö°</span>
                      Real-time Sync
                    </div>
                  </div>
                </div>
              </div>

              {/* Enhanced Local Mode Info Alert */}
              {serverStatus.status === "local-mode" && (
                <div className="glass-card-dark rounded-2xl p-6 mb-6 border border-cyan-400/30 relative overflow-hidden">
                  <div className="absolute top-0 left-0 w-full h-1 gradient-info"></div>
                  <div className="absolute top-2 right-2 w-16 h-16 bg-cyan-400/10 rounded-full"></div>
                  <div className="flex items-start gap-4">
                    <div className="text-4xl file-icon text-cyan-400">‚ÑπÔ∏è</div>
                    <div>
                      <h4 className="font-bold text-xl text-cyan-300 mb-2">Running in Local Mode</h4>
                      <div className="text-white/80 leading-relaxed">
                        The relay is operating in <span className="font-semibold text-cyan-300">local-only mode</span> with onchain features disabled. 
                        File storage, IPFS integration, and basic relay functions are available. 
                        To enable blockchain features, configure onchain membership in settings.
                      </div>
                    </div>
                  </div>
                </div>
              )}

              {/* Enhanced Stats Cards */}
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
                <div className="stat glass-card-dark hover-lift hover-glow gradient-primary rounded-2xl border-0 text-white relative overflow-hidden">
                  <div className="absolute top-0 right-0 w-20 h-20 bg-white/10 rounded-full -translate-y-6 translate-x-6"></div>
                  <div className="stat-figure text-white text-4xl file-icon">üìÅ</div>
                  <div className="stat-title text-white/80 font-medium">Total Files</div>
                  <div className="stat-value text-white text-3xl font-bold">
                    {dataLoading ? (
                      <div className="flex items-center gap-2">
                        <span className="loading loading-spinner loading-sm"></span>
                        <span className="shimmer rounded w-16 h-8"></span>
                      </div>
                    ) : (
                      <span className="drop-shadow-lg">{fileStats.count}</span>
                    )}
                  </div>
                  <div className="stat-desc text-white/70 font-medium">
                    <span className="status-dot status-online"></span>
                    {dataLoading ? "Loading..." : "Real files from relay"}
                  </div>
                </div>
                
                <div className="stat glass-card-dark hover-lift hover-glow gradient-success rounded-2xl border-0 text-white relative overflow-hidden">
                  <div className="absolute top-0 right-0 w-20 h-20 bg-white/10 rounded-full -translate-y-6 translate-x-6"></div>
                  <div className="stat-figure text-white text-4xl file-icon">üíæ</div>
                  <div className="stat-title text-white/80 font-medium">Storage Used</div>
                  <div className="stat-value text-white text-2xl font-bold">
                    {dataLoading ? (
                      <div className="flex items-center gap-2">
                        <span className="loading loading-spinner loading-sm"></span>
                        <span className="shimmer rounded w-20 h-8"></span>
                      </div>
                    ) : (
                      <span className="drop-shadow-lg">{formatFileSize(fileStats.totalSize)}</span>
                    )}
                  </div>
                  <div className="stat-desc text-white/70 font-medium">
                    <span className="status-dot status-online"></span>
                    {dataLoading ? "Calculating..." : "Actual storage usage"}
                  </div>
                </div>
                
                <div className="stat glass-card-dark hover-lift hover-glow gradient-info rounded-2xl border-0 text-white relative overflow-hidden">
                  <div className="absolute top-0 right-0 w-20 h-20 bg-white/10 rounded-full -translate-y-6 translate-x-6"></div>
                  <div className="stat-figure text-white text-4xl file-icon">üñ•Ô∏è</div>
                  <div className="stat-title text-white/80 font-medium">Server Status</div>
                  <div className="stat-value">
                    {dataLoading ? (
                      <div className="flex items-center gap-2">
                        <span className="loading loading-spinner loading-sm"></span>
                        <span className="shimmer rounded w-24 h-6"></span>
                      </div>
                    ) : (
                      <span className={`badge badge-lg font-bold border-0 ${
                        serverStatus.status === "online" ? "gradient-success text-white" : 
                        serverStatus.status === "local-mode" ? "gradient-warning text-white" :
                        serverStatus.status === "checking..." ? "gradient-info text-white" : 
                        "gradient-error text-white"
                      }`}>
                        {serverStatus.status === "local-mode" ? "Local Mode" : serverStatus.status}
                      </span>
                    )}
                  </div>
                  <div className="stat-desc text-white/70 font-medium">
                    <span className={`status-dot ${
                      serverStatus.status === "online" ? "status-online" :
                      serverStatus.status === "local-mode" ? "status-warning" :
                      "status-offline"
                    }`}></span>
                    {serverStatus.message ? serverStatus.message : `Port: ${serverStatus.port}`}
                  </div>
                </div>
                
                <div className="stat glass-card-dark hover-lift hover-glow gradient-warning rounded-2xl border-0 text-white relative overflow-hidden">
                  <div className="absolute top-0 right-0 w-20 h-20 bg-white/10 rounded-full -translate-y-6 translate-x-6"></div>
                  <div className="stat-figure text-white text-4xl file-icon">üåê</div>
                  <div className="stat-title text-white/80 font-medium">IPFS Status</div>
                  <div className="stat-value">
                    {dataLoading ? (
                      <div className="flex items-center gap-2">
                        <span className="loading loading-spinner loading-sm"></span>
                        <span className="shimmer rounded w-20 h-6"></span>
                      </div>
                    ) : ipfsConnectionStatus && ipfsConnectionStatus.status === 'connected' ? (
                      <span className="badge badge-lg gradient-success text-white font-bold border-0">Active</span>
                    ) : ipfsConnectionStatus && ipfsConnectionStatus.status === 'disabled' ? (
                      <span className="badge badge-lg gradient-warning text-white font-bold border-0">Disabled</span>
                    ) : ipfsConnectionStatus && ipfsConnectionStatus.status === 'error' ? (
                      <span className="badge badge-lg gradient-error text-white font-bold border-0">Error</span>
                    ) : (
                      <span className="badge badge-lg gradient-info text-white font-bold border-0">Checking...</span>
                    )}
                  </div>
                  <div className="stat-desc text-white/70 font-medium">
                    <span className={`status-dot ${
                      ipfsConnectionStatus && ipfsConnectionStatus.status === 'connected' ? 'status-online' :
                      ipfsConnectionStatus && ipfsConnectionStatus.status === 'disabled' ? 'status-warning' :
                      'status-offline'
                    }`}></span>
                    {ipfsConnectionStatus && ipfsConnectionStatus.message ? 
                     ipfsConnectionStatus.message : 
                     "IPFS service status"}
                  </div>
                </div>
              </div>

              {/* Gun.js Network Statistics */}
              <div className="glass-card-dark rounded-3xl p-8 mb-8 relative overflow-hidden border border-white/20">
                <div className="absolute top-0 left-0 w-full h-full bg-gradient-to-br from-purple-500/10 via-blue-500/10 to-green-500/10"></div>
                <div className="absolute top-4 right-4 w-40 h-40 bg-white/5 rounded-full -translate-y-8 translate-x-8"></div>
                <div className="absolute bottom-4 left-4 w-28 h-28 bg-white/5 rounded-full translate-y-8 -translate-x-8"></div>
                <div className="relative z-10">
                  <div className="flex items-center gap-4 mb-6">
                    <div className="text-5xl file-icon">üîó</div>
                    <div>
                      <h2 className="text-3xl font-bold mb-2 bg-gradient-to-r from-purple-400 via-blue-400 to-green-400 bg-clip-text text-transparent drop-shadow-lg">
                        Gun.js Network Statistics
                      </h2>
                      <p className="text-lg text-white/80">Real-time peer-to-peer network metrics</p>
                    </div>
                  </div>
                  
                  <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4">
                    {/* Peers Connected */}
                    <div className="stat glass-card hover-lift rounded-xl border border-white/20 text-center">
                      <div className="stat-figure text-purple-400 text-3xl file-icon">üë•</div>
                      <div className="stat-title text-white/60 text-sm font-medium">Peers</div>
                      <div className="stat-value text-white text-2xl font-bold">
                        {gunStats.peers.count}
                      </div>
                      <div className="stat-desc text-white/50 text-xs">
                        <span className="status-dot status-online"></span>Connected
                      </div>
                    </div>

                    {/* Peer Time */}
                    <div className="stat glass-card hover-lift rounded-xl border border-white/20 text-center">
                      <div className="stat-figure text-blue-400 text-3xl file-icon">‚è±Ô∏è</div>
                      <div className="stat-title text-white/60 text-sm font-medium">Peer Time</div>
                      <div className="stat-value text-white text-xl font-bold">
                        {Math.round(gunStats.peers.time / 1000 / 60)}m
                      </div>
                      <div className="stat-desc text-white/50 text-xs">
                        <span className="status-dot status-info"></span>Duration
                      </div>
                    </div>

                    {/* Nodes */}
                    <div className="stat glass-card hover-lift rounded-xl border border-white/20 text-center">
                      <div className="stat-figure text-green-400 text-3xl file-icon">üåê</div>
                      <div className="stat-title text-white/60 text-sm font-medium">Nodes</div>
                      <div className="stat-value text-white text-2xl font-bold">
                        {gunStats.nodes.count}
                      </div>
                      <div className="stat-desc text-white/50 text-xs">
                        <span className="status-dot status-online"></span>Active
                      </div>
                    </div>

                    {/* Uptime */}
                    <div className="stat glass-card hover-lift rounded-xl border border-white/20 text-center">
                      <div className="stat-figure text-yellow-400 text-3xl file-icon">‚è∞</div>
                      <div className="stat-title text-white/60 text-sm font-medium">Uptime</div>
                      <div className="stat-value text-white text-xl font-bold">
                        {(gunStats.uptime.time / 60 / 60).toFixed(1)}h
                      </div>
                      <div className="stat-desc text-white/50 text-xs">
                        <span className="status-dot status-online"></span>Hours
                      </div>
                    </div>

                    {/* Memory */}
                    <div className="stat glass-card hover-lift rounded-xl border border-white/20 text-center">
                      <div className="stat-figure text-red-400 text-3xl file-icon">üß†</div>
                      <div className="stat-title text-white/60 text-sm font-medium">Memory</div>
                      <div className="stat-value text-white text-lg font-bold">
                        {(gunStats.memory.heapTotal / 1024 / 1024).toFixed(0)}MB
                      </div>
                      <div className="stat-desc text-white/50 text-xs">
                        <span className="status-dot status-warning"></span>Heap
                      </div>
                    </div>

                    {/* Block Time */}
                    <div className="stat glass-card hover-lift rounded-xl border border-white/20 text-center">
                      <div className="stat-figure text-indigo-400 text-3xl file-icon">‚ö°</div>
                      <div className="stat-title text-white/60 text-sm font-medium">Block</div>
                      <div className="stat-value text-white text-lg font-bold">
                        {gunStats.block.toFixed(1)}s
                      </div>
                      <div className="stat-desc text-white/50 text-xs">
                        <span className="status-dot status-info"></span>Avg Time
                      </div>
                    </div>
                  </div>

                  {/* DAM (Data Access Module) Statistics */}
                  <div className="mt-6 pt-6 border-t border-white/20">
                    <h3 className="text-xl font-bold text-white mb-4 flex items-center gap-2">
                      <span className="file-icon text-2xl">üì°</span>
                      DAM Network Activity
                    </h3>
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                      {/* DAM In Count */}
                      <div className="stat glass-card hover-lift rounded-xl border border-white/20 text-center">
                        <div className="stat-figure text-cyan-400 text-2xl file-icon">üì•</div>
                        <div className="stat-title text-white/60 text-sm font-medium">In Count</div>
                        <div className="stat-value text-white text-lg font-bold">
                          {gunStats.dam.in.count}
                        </div>
                        <div className="stat-desc text-white/50 text-xs">
                          <span className="status-dot status-online"></span>Messages
                        </div>
                      </div>

                      {/* DAM In Size */}
                      <div className="stat glass-card hover-lift rounded-xl border border-white/20 text-center">
                        <div className="stat-figure text-teal-400 text-2xl file-icon">üìä</div>
                        <div className="stat-title text-white/60 text-sm font-medium">In Size</div>
                        <div className="stat-value text-white text-lg font-bold">
                          {(gunStats.dam.in.done / 1024 / 1024).toFixed(1)}MB
                        </div>
                        <div className="stat-desc text-white/50 text-xs">
                          <span className="status-dot status-online"></span>Received
                        </div>
                      </div>

                      {/* DAM Out Count */}
                      <div className="stat glass-card hover-lift rounded-xl border border-white/20 text-center">
                        <div className="stat-figure text-orange-400 text-2xl file-icon">üì§</div>
                        <div className="stat-title text-white/60 text-sm font-medium">Out Count</div>
                        <div className="stat-value text-white text-lg font-bold">
                          {gunStats.dam.out.count}
                        </div>
                        <div className="stat-desc text-white/50 text-xs">
                          <span className="status-dot status-online"></span>Messages
                        </div>
                      </div>

                      {/* DAM Out Size */}
                      <div className="stat glass-card hover-lift rounded-xl border border-white/20 text-center">
                        <div className="stat-figure text-pink-400 text-2xl file-icon">üìà</div>
                        <div className="stat-title text-white/60 text-sm font-medium">Out Size</div>
                        <div className="stat-value text-white text-lg font-bold">
                          {(gunStats.dam.out.done / 1024 / 1024).toFixed(1)}MB
                        </div>
                        <div className="stat-desc text-white/50 text-xs">
                          <span className="status-dot status-online"></span>Sent
                        </div>
                      </div>
                    </div>
                  </div>

                  {/* Quick Actions for Gun Stats */}
                  <div className="mt-6 flex gap-3">
                    <button 
                      className="btn btn-enhanced gradient-purple text-white border-0 hover-lift"
                      onClick={loadGunStats}
                    >
                      <span className="file-icon text-xl">üîÑ</span>
                      <span className="font-semibold">Refresh Gun Stats</span>
                    </button>
                    <button 
                      className="btn btn-enhanced glass-card border border-white/20 text-white/80 hover:text-white hover:gradient-info"
                      onClick={() => {
                        const statsDetails = `
Gun.js Network Statistics:
- Peers Connected: ${gunStats.peers.count}
- Peer Time: ${Math.round(gunStats.peers.time / 1000 / 60)} minutes
- Active Nodes: ${gunStats.nodes.count}
- Uptime: ${(gunStats.uptime.time / 60 / 60).toFixed(1)} hours
- Memory Usage: ${(gunStats.memory.heapTotal / 1024 / 1024).toFixed(1)} MB
- DAM In: ${gunStats.dam.in.count} messages (${(gunStats.dam.in.done / 1024 / 1024).toFixed(1)} MB)
- DAM Out: ${gunStats.dam.out.count} messages (${(gunStats.dam.out.done / 1024 / 1024).toFixed(1)} MB)
                        `.trim();
                        
                        navigator.clipboard.writeText(statsDetails);
                        toast.success('üìã Gun stats copied to clipboard!');
                      }}
                    >
                      <span className="file-icon text-xl">üìã</span>
                      <span className="font-semibold">Copy Stats</span>
                    </button>
                  </div>
                </div>
              </div>

              {/* Enhanced Navigation Tabs */}
              <div className="glass-card-dark shadow-2xl border-0 backdrop-blur-xl">
                <div className="flex flex-wrap px-6 pt-6 gap-2">
                  <button 
                    className={`btn btn-enhanced transition-all duration-300 ${
                      activeTab === "files" 
                        ? "gradient-primary text-white border-0 shadow-lg scale-105" 
                        : "glass-card border border-white/20 text-white/80 hover:text-white hover:scale-105 hover:gradient-primary"
                    }`}
                    onClick={() => {
                      console.log('üîç Switching to files tab');
                      setActiveTab("files");
                      toast.info('üìÅ Files tab activated');
                    }}
                  >
                    <span className="file-icon text-2xl">üìÅ</span>
                    <span className="font-semibold">Files Manager</span>
                  </button>
                  <button 
                    className={`btn btn-enhanced transition-all duration-300 ${
                      activeTab === "upload" 
                        ? "gradient-success text-white border-0 shadow-lg scale-105" 
                        : "glass-card border border-white/20 text-white/80 hover:text-white hover:scale-105 hover:gradient-success"
                    }`}
                    onClick={() => {
                      console.log('üîç Switching to upload tab');
                      setActiveTab("upload");
                      toast.info('üì§ Upload tab activated');
                    }}
                  >
                    <span className="file-icon text-2xl">üì§</span>
                    <span className="font-semibold">Upload Zone</span>
                  </button>
                  <button 
                    className={`btn btn-enhanced transition-all duration-300 ${
                      activeTab === "settings" 
                        ? "gradient-warning text-white border-0 shadow-lg scale-105" 
                        : "glass-card border border-white/20 text-white/80 hover:text-white hover:scale-105 hover:gradient-warning"
                    }`}
                    onClick={() => {
                      console.log('üîç Switching to settings tab');
                      setActiveTab("settings");
                      toast.info('‚öôÔ∏è Configuration tab activated');
                    }}
                  >
                    <span className="file-icon text-2xl">‚öôÔ∏è</span>
                    <span className="font-semibold">Configuration</span>
                  </button>
                </div>

                <div className="p-8 tab-content glass-card min-h-[600px] rounded-2xl mt-4 mx-4 mb-4 border border-white/10">
                  {/* Tab Content */}
                  {console.log('üéØ About to render tab content for:', activeTab) || null}
                  {activeTab === "files" ? (
                    <div className="space-y-6">
                      {console.log('üìÅ Rendering FILES tab content') || null}
                      <div className="flex items-center justify-between">
                        <h2 className="text-3xl font-bold text-primary">üìÅ Files Management</h2>
                        <div className="flex gap-3">
                          <button 
                            className={`btn btn-enhanced gradient-primary text-white border-0 hover-lift ${dataLoading ? 'loading' : ''}`} 
                            onClick={loadRealData}
                            disabled={dataLoading}
                          >
                            {dataLoading ? (
                              <span className="loading loading-spinner loading-sm"></span>
                            ) : (
                              <span className="file-icon text-xl">üîÑ</span>
                            )}
                            <span className="font-semibold">{dataLoading ? 'Loading...' : 'Refresh Real Data'}</span>
                          </button>
                          <button 
                            className="btn btn-enhanced gradient-warning text-white border-0 hover-lift"
                            onClick={async () => {
                              try {
                                toast.info('üîÑ Checking for files to recover...');
                                const authToken = window.localStorage.getItem('shogun_token') || 'shogun2025';
                                
                                // First check if there are fallback files
                                const checkResponse = await fetch('/api/ipfs/fallback-files', {
                                  headers: { 'Authorization': `Bearer ${authToken}` }
                                });
                                
                                if (checkResponse.ok) {
                                  const checkData = await checkResponse.json();
                                  if (checkData.success && checkData.count > 0) {
                                    const confirmRecover = confirm(`Found ${checkData.count} files in fallback. Recover them to the main database?`);
                                    if (confirmRecover) {
                                      toast.info('üîÑ Recovering files from fallback...');
                                      
                                      const recoverResponse = await fetch('/api/ipfs/recover-fallback', {
                                        method: 'POST',
                                        headers: { 'Authorization': `Bearer ${authToken}` }
                                      });
                                      
                                      if (recoverResponse.ok) {
                                        const recoverData = await recoverResponse.json();
                                        if (recoverData.success) {
                                          toast.success(`‚úÖ Recovered ${recoverData.recovered}/${recoverData.total} files!`);
                                          // Refresh the file list
                                          await loadRealData();
                                        } else {
                                          toast.error('‚ùå Recovery failed: ' + recoverData.message);
                                        }
                                      } else {
                                        toast.error('‚ùå Recovery request failed');
                                      }
                                    }
                                  } else {
                                    toast.info('‚ÑπÔ∏è No files found in fallback to recover');
                                  }
                                } else {
                                  toast.error('‚ùå Could not check fallback files');
                                }
                              } catch (error) {
                                console.error('Recovery error:', error);
                                toast.error('‚ùå Recovery error: ' + error.message);
                              }
                            }}
                            title="Recover IPFS files from fallback storage"
                          >
                            üîß Recover IPFS Files
                          </button>
                        </div>
                      </div>
                      
                      {/* File Filter Tabs */}
                      <div className="card bg-base-100 shadow-lg border border-base-300">
                        <div className="card-body">
                          <div className="tabs tabs-boxed bg-base-200">
                            <button 
                              className={`tab ${fileFilter === 'all' ? 'tab-active' : ''}`}
                              onClick={() => setFileFilter('all')}
                            >
                              üìÇ All Files ({realFiles.length})
                            </button>
                            <button 
                              className={`tab ${fileFilter === 'local' ? 'tab-active' : ''}`}
                              onClick={() => setFileFilter('local')}
                            >
                              üìÅ Local ({realFiles.filter(f => f.storageType === 'local-only' || f.storageType === 'local-with-ipfs').length})
                            </button>
                            <button 
                              className={`tab ${fileFilter === 'ipfs' ? 'tab-active' : ''}`}
                              onClick={() => setFileFilter('ipfs')}
                            >
                              üåê IPFS ({realFiles.filter(f => f.storageType === 'ipfs-independent' || f.ipfsHash).length})
                              {ipfsConnectionStatus.status !== 'connected' && (
                                <div className="badge badge-warning badge-xs ml-2">Offline</div>
                              )}
                            </button>
                          </div>
                          
                          {/* IPFS Warning */}
                          {fileFilter === 'ipfs' && ipfsConnectionStatus.status !== 'connected' && (
                            <div className="alert alert-warning mt-4">
                              <div>
                                <h4 className="font-bold">‚ö†Ô∏è IPFS Service Unavailable</h4>
                                <div className="text-sm">
                                  IPFS files may not be accessible because the IPFS service is currently offline. 
                                  Files stored on IPFS network might not load properly.
                                </div>
                              </div>
                            </div>
                          )}
                        </div>
                      </div>
                      
                      <div className="alert alert-success">
                        <div>
                          <h3 className="font-bold">‚úÖ Files Loaded Successfully!</h3>
                          <div className="text-sm">
                            {realFiles.length > 0 
                              ? `Found ${realFiles.length} files using ${formatFileSize(fileStats.totalSize)} storage.`
                              : "No files found in relay - try uploading some files!"
                            }
                          </div>
                        </div>
                      </div>

                      <div className="overflow-x-auto bg-base-200 rounded-lg p-4">
                        {dataLoading ? (
                          <div className="text-center py-8">
                            <div className="loading loading-spinner loading-lg text-primary mb-4"></div>
                            <p>Loading real files from relay...</p>
                          </div>
                        ) : realFiles.length === 0 ? (
                          <div className="text-center py-8">
                            <div className="text-6xl mb-4">üìÇ</div>
                            <h3 className="text-xl font-bold mb-2">No Files Found</h3>
                            <p className="text-base-content/70 mb-4">The relay doesn't have any files yet.</p>
                            <button 
                              className="btn btn-primary" 
                              onClick={() => {
                                setActiveTab("upload");
                                toast.info('üì§ Switch to upload tab to add files');
                              }}
                            >
                              üì§ Upload Files
                            </button>
                          </div>
                        ) : realFiles.filter(file => {
                          if (fileFilter === 'all') return true;
                          if (fileFilter === 'local') {
                            return file.storageType === 'local-only' || file.storageType === 'local-with-ipfs';
                          }
                          if (fileFilter === 'ipfs') {
                            return file.storageType === 'ipfs-independent' || file.ipfsHash;
                          }
                          return true;
                        }).length === 0 ? (
                          <div className="text-center py-8">
                            <div className="text-6xl mb-4">
                              {fileFilter === 'local' ? 'üìÅ' : fileFilter === 'ipfs' ? 'üåê' : 'üìÇ'}
                            </div>
                            <h3 className="text-xl font-bold mb-2">
                              No {fileFilter === 'local' ? 'Local' : fileFilter === 'ipfs' ? 'IPFS' : ''} Files Found
                            </h3>
                            <p className="text-base-content/70 mb-4">
                              {fileFilter === 'local' 
                                ? 'No files stored locally on the server.' 
                                : fileFilter === 'ipfs' 
                                ? 'No files stored on IPFS network.' 
                                : 'No files found with current filter.'
                              }
                            </p>
                            <div className="flex gap-2 justify-center">
                              <button 
                                className="btn btn-outline" 
                                onClick={() => setFileFilter('all')}
                              >
                                üìÇ Show All Files
                              </button>
                              <button 
                                className="btn btn-primary" 
                                onClick={() => {
                                  setActiveTab("upload");
                                  toast.info('üì§ Switch to upload tab to add files');
                                }}
                              >
                                üì§ Upload Files
                              </button>
                            </div>
                          </div>
                        ) : (
                          <table className="table table-zebra w-full">
                            <thead>
                              <tr>
                                <th className="bg-primary text-primary-content">üìÑ File</th>
                                <th className="bg-primary text-primary-content">üìè Size</th>
                                <th className="bg-primary text-primary-content">üè∑Ô∏è Type</th>
                                <th className="bg-primary text-primary-content">üìä Status</th>
                                <th className="bg-primary text-primary-content">‚ö° Actions</th>
                              </tr>
                            </thead>
                            <tbody>
                              {realFiles.filter(file => {
                                if (fileFilter === 'all') return true;
                                if (fileFilter === 'local') {
                                  return file.storageType === 'local-only' || file.storageType === 'local-with-ipfs';
                                }
                                if (fileFilter === 'ipfs') {
                                  return file.storageType === 'ipfs-independent' || file.ipfsHash;
                                }
                                return true;
                              }).map((file, index) => {
                                const getFileIcon = (mimetype) => {
                                  if (!mimetype) return "üìÑ";
                                  if (mimetype.startsWith('image/')) return "üñºÔ∏è";
                                  if (mimetype.startsWith('video/')) return "üé•";
                                  if (mimetype.startsWith('audio/')) return "üéµ";
                                  if (mimetype.includes('pdf')) return "üìï";
                                  if (mimetype.includes('json')) return "‚öôÔ∏è";
                                  if (mimetype.includes('text')) return "üìù";
                                  return "üìÑ";
                                };
                                
                                const getFileTypeLabel = (mimetype) => {
                                  if (!mimetype) return "Unknown";
                                  if (mimetype.startsWith('image/')) return "Image";
                                  if (mimetype.startsWith('video/')) return "Video";
                                  if (mimetype.startsWith('audio/')) return "Audio";
                                  if (mimetype.includes('pdf')) return "PDF";
                                  if (mimetype.includes('json')) return "Config";
                                  if (mimetype.includes('text')) return "Text";
                                  return mimetype.split('/')[0] || "File";
                                };
                                
                                return (
                                  <tr key={file.id || index} className="hover">
                                    <td>
                                      <div className="flex items-center gap-3">
                                        <div className="text-2xl">{getFileIcon(file.mimetype)}</div>
                                        <div>
                                          <div className="font-bold">{file.originalName || file.filename || `file_${index}`}</div>
                                          <div className="text-sm opacity-70">ID: {file.id || `file_${index}`}</div>
                                        </div>
                                      </div>
                                    </td>
                                    <td>
                                      <span className="badge badge-outline">{formatFileSize(file.size || 0)}</span>
                                    </td>
                                    <td>
                                      <span className="badge badge-secondary">{getFileTypeLabel(file.mimetype)}</span>
                                    </td>
                                    <td>
                                      <div className="flex flex-col gap-1">
                                        {file.storageType === 'local-only' && (
                                          <span className="badge badge-info">üìÅ Local Only</span>
                                        )}
                                        {file.storageType === 'local-with-ipfs' && (
                                          <span className="badge badge-success">üìÅüåê Local + IPFS</span>
                                        )}
                                        {file.storageType === 'ipfs-independent' && (
                                          <span className="badge badge-warning">üåê IPFS Only</span>
                                        )}
                                        {!file.storageType && file.ipfsHash && (
                                          <span className="badge badge-secondary">üåê IPFS</span>
                                        )}
                                        {!file.storageType && !file.ipfsHash && (
                                          <span className="badge badge-outline">üìÅ Local</span>
                                        )}
                                        
                                        {/* IPFS Accessibility Warning */}
                                        {(file.storageType === 'ipfs-independent' || (file.ipfsHash && !file.fileUrl)) && 
                                         ipfsConnectionStatus.status !== 'connected' && (
                                          <span className="badge badge-error badge-xs">‚ö†Ô∏è Offline</span>
                                        )}
                                      </div>
                                    </td>
                                    <td>
                                      <div className="flex gap-1">
                                        <button 
                                          className="btn btn-ghost btn-sm text-primary" 
                                          onClick={() => handleFileView(file)}
                                          disabled={dataLoading}
                                          title="View file"
                                        >
                                          üëÅÔ∏è
                                        </button>
                                        <button 
                                          className="btn btn-ghost btn-sm text-success" 
                                          onClick={() => handleFileDownload(file)}
                                          disabled={dataLoading}
                                          title="Download file"
                                        >
                                          ‚¨áÔ∏è
                                        </button>
                                        <button 
                                          className="btn btn-ghost btn-sm text-info" 
                                          onClick={() => handleFileInfo(file)}
                                          title="File information"
                                        >
                                          ‚ÑπÔ∏è
                                        </button>
                                        <button 
                                          className="btn btn-ghost btn-sm text-warning" 
                                          onClick={() => handleFileShare(file)}
                                          disabled={dataLoading}
                                          title="Create shareable link"
                                        >
                                          üîó
                                        </button>
                                        <button 
                                          className="btn btn-ghost btn-sm text-error" 
                                          onClick={() => handleFileDelete(file)}
                                          disabled={dataLoading}
                                          title="Delete file"
                                        >
                                          üóëÔ∏è
                                        </button>
                                      </div>
                                    </td>
                                  </tr>
                                );
                              })}
                            </tbody>
                          </table>
                        )}
                      </div>
                    </div>

                  ) : activeTab === "upload" ? (
                    <div className="space-y-6">
                      <h2 className="text-3xl font-bold text-secondary">üì§ File Upload Zone</h2>
                      
                      <div className="alert alert-info">
                        <div>
                          <h3 className="font-bold">‚ÑπÔ∏è Enhanced Upload System</h3>
                          <div className="text-sm">Drag & drop now powered by React hooks with real-time progress tracking!</div>
                        </div>
                      </div>

                      {/* Upload Target Selection */}
                      <div className="card bg-base-100 shadow-lg border border-base-300">
                        <div className="card-body">
                          <h3 className="card-title text-primary">üéØ Upload Destination</h3>
                          <p className="text-sm text-base-content/70 mb-4">Choose where to store your files</p>
                          
                          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                            <div className={`card cursor-pointer transition-all duration-200 ${uploadTarget === 'auto' ? 'bg-primary text-primary-content border-primary' : 'bg-base-200 hover:bg-base-300'}`}
                                 onClick={() => setUploadTarget('auto')}>
                              <div className="card-body text-center p-4">
                                <div className="text-2xl mb-2">ü§ñ</div>
                                <h4 className="font-bold text-sm">Auto Mode</h4>
                                <p className="text-xs opacity-70">IPFS if available, otherwise local</p>
                              </div>
                            </div>
                            
                            <div className={`card cursor-pointer transition-all duration-200 ${uploadTarget === 'ipfs' ? 'bg-success text-success-content border-success' : 'bg-base-200 hover:bg-base-300'}`}
                                 onClick={() => setUploadTarget('ipfs')}>
                              <div className="card-body text-center p-4">
                                <div className="text-2xl mb-2">üåê</div>
                                <h4 className="font-bold text-sm">IPFS Network</h4>
                                <p className="text-xs opacity-70">Decentralized storage</p>
                                {ipfsConnectionStatus.status !== 'connected' && (
                                  <div className="badge badge-warning badge-xs mt-1">Unavailable</div>
                                )}
                              </div>
                            </div>
                            
                            <div className={`card cursor-pointer transition-all duration-200 ${uploadTarget === 'local' ? 'bg-info text-info-content border-info' : 'bg-base-200 hover:bg-base-300'}`}
                                 onClick={() => setUploadTarget('local')}>
                              <div className="card-body text-center p-4">
                                <div className="text-2xl mb-2">üìÅ</div>
                                <h4 className="font-bold text-sm">Local Storage</h4>
                                <p className="text-xs opacity-70">Server file system</p>
                              </div>
                            </div>
                          </div>
                          
                          <div className="mt-4 p-3 bg-base-200 rounded-lg">
                            <div className="text-sm">
                              <span className="font-medium">Current selection:</span>
                              <span className="ml-2 badge badge-outline">
                                {uploadTarget === 'auto' ? 'ü§ñ Auto Mode' : 
                                 uploadTarget === 'ipfs' ? 'üåê IPFS Network' : 
                                 'üìÅ Local Storage'}
                              </span>
                            </div>
                          </div>
                        </div>
                      </div>

                      <div 
                        className="border-2 border-dashed border-primary rounded-lg p-12 text-center hover:border-secondary transition-all duration-300 bg-gradient-to-br from-primary/5 to-secondary/5"
                        onDrop={handleDrop}
                        onDragOver={handleDragOver}
                        onDragEnter={handleDragEnter}
                        onDragLeave={handleDragLeave}
                      >
                        <div className="text-8xl mb-6">üìÅ</div>
                        <h3 className="text-2xl font-bold mb-4">Drop files here to upload</h3>
                        <p className="text-base-content/70 mb-6">
                          Drag & drop or select files ‚Ä¢ Uploads to IPFS ‚Ä¢ Max 500MB per file
                        </p>
                        {dataLoading && (
                          <div className="mb-4">
                            <div className="loading loading-spinner loading-lg text-primary"></div>
                            <p className="mt-2">Uploading to IPFS...</p>
                          </div>
                        )}
                        <input 
                          type="file" 
                          multiple 
                          className="file-input file-input-bordered file-input-primary max-w-xs" 
                          onChange={handleFileUpload}
                          disabled={dataLoading}
                        />
                        
                        {/* Upload Progress Indicators */}
                        {Object.keys(uploadProgress).length > 0 && (
                          <div className="mt-6 space-y-2">
                            <h4 className="font-bold text-sm">Upload Progress:</h4>
                            {Object.entries(uploadProgress).map(([fileId, progress]) => (
                              <div key={fileId} className="flex items-center gap-2 text-sm">
                                <span className="min-w-0 flex-1 truncate">{fileId.split('_')[0]}</span>
                                {progress === -1 ? (
                                  <span className="text-error">‚ùå Failed</span>
                                ) : progress === 100 ? (
                                  <span className="text-success">‚úÖ Complete</span>
                                ) : (
                                  <span className="text-info">üì§ Uploading...</span>
                                )}
                              </div>
                            ))}
                          </div>
                        )}
                      </div>
                      
                      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                        <div className="card bg-gradient-to-br from-success/10 to-success/5 border border-success/20">
                          <div className="card-body text-center">
                            <h4 className="card-title justify-center text-success">üìä Upload Stats</h4>
                            <div className="text-3xl font-bold text-success">{dashboardStats.todayFiles || 0}</div>
                            <p className="text-sm opacity-70">Files Uploaded Today</p>
                            <div className="text-sm font-bold text-success">
                              üìÅ {dashboardStats.totalFiles || 0} total files
                            </div>
                          </div>
                        </div>
                        <div className="card bg-gradient-to-br from-info/10 to-info/5 border border-info/20">
                          <div className="card-body text-center">
                            <h4 className="card-title justify-center text-info">üîó Shared Links</h4>
                            <div className="text-3xl font-bold text-info">{dashboardStats.sharedLinks?.active || 0}</div>
                            <p className="text-sm opacity-70">Active Shared Links</p>
                            <div className="text-sm font-bold text-info">
                              üìä {dashboardStats.sharedLinks?.total || 0} total links
                            </div>
                          </div>
                        </div>
                        <div className="card bg-gradient-to-br from-warning/10 to-warning/5 border border-warning/20">
                          <div className="card-body text-center">
                            <h4 className="card-title justify-center text-warning">üíæ Storage</h4>
                            <div className="text-3xl font-bold text-warning">{dashboardStats.storage?.remainingPercentage || 0}%</div>
                            <p className="text-sm opacity-70">Space Remaining</p>
                            <div className="text-sm font-bold text-warning">
                              üìà {formatFileSize(dashboardStats.storage?.used || 0)} used
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>

                  ) : activeTab === "settings" ? (
                    <div className="space-y-8">
                      <h2 className="text-3xl font-bold text-accent">‚öôÔ∏è Dashboard Configuration</h2>
                      
                      <div className="alert alert-success">
                        <div>
                          <h3 className="font-bold">üì§ Upload Files</h3>
                          <div className="text-sm">
                            Drag and drop files or click to browse. Files are stored locally and optionally on IPFS network.
                          </div>
                        </div>
                      </div>

                      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        {/* Appearance Settings */}
                        <div className="card bg-base-100 shadow-lg border border-base-300">
                          <div className="card-body">
                            <h3 className="card-title text-primary">üé® Appearance</h3>
                            
                            <div className="form-control">
                              <label className="label">
                                <span className="label-text font-medium">Color Theme</span>
                                <span className="label-text-alt">{theme} mode</span>
                              </label>
                              <div className="flex items-center gap-4 p-3 bg-base-200 rounded-lg">
                                <span className="text-sm">‚òÄÔ∏è Light</span>
                                <input 
                                  type="checkbox" 
                                  className="toggle toggle-primary" 
                                  checked={theme === "dark"}
                                  onChange={toggleTheme}
                                />
                                <span className="text-sm">üåô Dark</span>
                              </div>
                            </div>

                            <div className="form-control">
                              <label className="label">
                                <span className="label-text font-medium">Dashboard Layout</span>
                              </label>
                              <select className="select select-bordered">
                                <option>Compact View</option>
                                <option>Comfortable View</option>
                                <option>Detailed View</option>
                              </select>
                            </div>
                          </div>
                        </div>

                        {/* Server Status */}
                        <div className="card bg-base-100 shadow-lg border border-base-300">
                          <div className="card-body">
                            <h3 className="card-title text-success">
                              üñ•Ô∏è Server Status
                              <div className="badge badge-success">{serverStatus.status}</div>
                            </h3>
                            
                            <div className="stats shadow bg-base-200 border border-base-300">
                              <div className="stat">
                                <div className="stat-title">Framework</div>
                                <div className="stat-value text-lg text-success">React 18 ‚úÖ</div>
                                <div className="stat-desc text-success">React Framework</div>
                              </div>
                            </div>

                            <div className="space-y-2 text-sm">
                              <div className="flex justify-between">
                                <span>Port:</span>
                                <span className="font-mono badge badge-outline">{serverStatus.port}</span>
                              </div>
                              <div className="flex justify-between">
                                <span>Uptime:</span>
                                <span className="badge badge-success">99.9%</span>
                              </div>
                              <div className="flex justify-between">
                                <span>Memory:</span>
                                <span className="badge badge-info">245 MB</span>
                              </div>
                            </div>
                          </div>
                        </div>

                        {/* IPFS Status */}
                        <div className="card bg-base-100 shadow-lg border border-base-300">
                          <div className="card-body">
                            <h3 className="card-title">
                              üåê IPFS Service
                              <div className={`badge ${ipfsConnectionStatus.status === 'connected' ? 'badge-success' : 'badge-error'}`}>
                                {ipfsConnectionStatus.status === 'connected' ? 'Active' : 'Inactive'}
                              </div>
                            </h3>
                            
                            <div className="space-y-3">
                              <div className="flex justify-between items-center">
                                <span className="text-sm font-medium">Service Status:</span>
                                <span className={`text-sm font-bold ${ipfsConnectionStatus.status === 'connected' ? 'text-success' : 'text-error'}`}>
                                  {ipfsConnectionStatus.status === 'connected' ? 'üü¢ Running' : 'üî¥ Disabled'}
                                </span>
                              </div>
                              
                              <div className="flex justify-between items-center">
                                <span className="text-sm font-medium">Upload Target:</span>
                                <span className="text-sm badge badge-outline">
                                  {ipfsConnectionStatus.status === 'connected' ? 'IPFS Network' : 'Local Storage'}
                                </span>
                              </div>
                              
                              <div className="flex justify-between items-center">
                                <span className="text-sm font-medium">Message:</span>
                                <span className="text-sm text-base-content/70">
                                  {ipfsConnectionStatus.message || 'Unknown'}
                                </span>
                              </div>
                              
                              <button 
                                className="btn btn-sm btn-primary w-full mt-3"
                                onClick={async () => {
                                  toast.info('üîÑ Checking IPFS status...');
                                  try {
                                    const response = await fetch('/api/ipfs/status', {
                                      headers: { 'Authorization': `Bearer ${window.localStorage.getItem('shogun_token') || 'shogun2025'}` }
                                    });
                                    const data = await response.json();
                                    if (data.success && data.status?.enabled) {
                                      setIpfsConnectionStatus({ status: 'connected', message: 'Service active' });
                                      toast.success('‚úÖ IPFS is active and ready for uploads!');
                                    } else {
                                      setIpfsConnectionStatus({ status: 'disconnected', message: 'Service disabled' });
                                      toast.warning('‚ö†Ô∏è IPFS service is not enabled - files will upload to local storage');
                                    }
                                  } catch (error) {
                                    setIpfsConnectionStatus({ status: 'error', message: 'Connection error' });
                                    toast.error('‚ùå Could not check IPFS status');
                                  }
                                }}
                              >
                                üîÑ Check IPFS Status
                              </button>
                            </div>
                          </div>
                        </div>

                        {/* Shared Links Management */}
                        <div className="card bg-base-100 shadow-lg border border-base-300">
                          <div className="card-body">
                            <h3 className="card-title text-warning">üîó Shared Links Management</h3>
                            
                            <div className="space-y-4">
                              <div className="flex justify-between items-center">
                                <span className="text-sm font-medium">Active Shared Links:</span>
                                <div className="flex gap-2">
                                  <button 
                                    className="btn btn-sm btn-outline"
                                    onClick={async () => {
                                      try {
                                        toast.info('Loading shared links...');
                                        const response = await fetch('/api/files/shared-links', {
                                          headers: { 'Authorization': `Bearer ${window.localStorage.getItem('shogun_token') || 'shogun2025'}` }
                                        });
                                        
                                        if (!response.ok) {
                                          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                                        }
                                        
                                        const data = await response.json();
                                        console.log('üìã Shared links response:', data);
                                        
                                        if (data.success) {
                                          if (data.sharedLinks && data.sharedLinks.length > 0) {
                                            const linksInfo = data.sharedLinks.map(link => {
                                              const statusIcon = link.status === 'exhausted' ? 'üö´' : 
                                                               link.status === 'expired' ? '‚è∞' : '‚úÖ';
                                              const statusText = link.status === 'exhausted' ? ' (EXHAUSTED)' : 
                                                               link.status === 'expired' ? ' (EXPIRED)' : '';
                                              return `${statusIcon} ${link.fileName}${statusText}\n   Downloads: ${link.downloadCount}/${link.maxDownloads}\n   Created: ${new Date(link.createdAt).toLocaleDateString()}\n   URL: ${link.shareUrl}\n`;
                                            }).join('\n');
                                            alert(`üìã Active Shared Links (${data.count}):\n\n${linksInfo}`);
                                            toast.success(`Found ${data.count} shared links`);
                                          } else {
                                            // If no links found, try reloading from GunDB
                                            toast.info('No links found, trying to reload from database...');
                                            const reloadResponse = await fetch('/api/files/shared-links/reload', {
                                              method: 'POST',
                                              headers: { 'Authorization': `Bearer ${window.localStorage.getItem('shogun_token') || 'shogun2025'}` }
                                            });
                                            
                                            if (reloadResponse.ok) {
                                              const reloadData = await reloadResponse.json();
                                              if (reloadData.success && reloadData.newCount > 0) {
                                                toast.success(`Reloaded ${reloadData.newCount} links from database`);
                                                // Retry fetching links
                                                setTimeout(async () => {
                                                  const retryResponse = await fetch('/api/files/shared-links', {
                                                    headers: { 'Authorization': `Bearer ${window.localStorage.getItem('shogun_token') || 'shogun2025'}` }
                                                  });
                                                  const retryData = await retryResponse.json();
                                                  if (retryData.success && retryData.sharedLinks.length > 0) {
                                                    const linksInfo = retryData.sharedLinks.map(link => {
                                                      const statusIcon = link.status === 'exhausted' ? 'üö´' : 
                                                                       link.status === 'expired' ? '‚è∞' : '‚úÖ';
                                                      const statusText = link.status === 'exhausted' ? ' (EXHAUSTED)' : 
                                                                       link.status === 'expired' ? ' (EXPIRED)' : '';
                                                      return `${statusIcon} ${link.fileName}${statusText}\n   Downloads: ${link.downloadCount}/${link.maxDownloads}\n   Created: ${new Date(link.createdAt).toLocaleDateString()}\n   URL: ${link.shareUrl}\n`;
                                                    }).join('\n');
                                                    alert(`üìã Active Shared Links (${retryData.count}):\n\n${linksInfo}`);
                                                  }
                                                }, 1000);
                                              } else {
                                                alert('üìã No active shared links found.\n\nCreate shared links by clicking the üîó button next to files in the Files tab.');
                                                toast.info('No shared links found in database');
                                              }
                                            } else {
                                              alert('üìã No active shared links found.\n\nCreate shared links by clicking the üîó button next to files in the Files tab.');
                                              toast.info('No shared links found');
                                            }
                                          }
                                        } else {
                                          toast.error('Failed to load shared links: ' + (data.error || 'Unknown error'));
                                        }
                                      } catch (error) {
                                        console.error('Error loading shared links:', error);
                                        toast.error('Error loading shared links: ' + error.message);
                                      }
                                    }}
                                  >
                                    üìã View All Links
                                  </button>
                                  <button 
                                    className="btn btn-sm btn-ghost"
                                    onClick={async () => {
                                      try {
                                        toast.info('üîÑ Reloading shared links from database...');
                                        const response = await fetch('/api/files/shared-links/reload', {
                                          method: 'POST',
                                          headers: { 'Authorization': `Bearer ${window.localStorage.getItem('shogun_token') || 'shogun2025'}` }
                                        });
                                        
                                        if (!response.ok) {
                                          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                                        }
                                        
                                        const data = await response.json();
                                        console.log('üîÑ Reload response:', data);
                                        
                                        if (data.success) {
                                          toast.success(`üîÑ Reloaded: ${data.previousCount} ‚Üí ${data.newCount} links`);
                                        } else {
                                          toast.error('Failed to reload: ' + (data.error || 'Unknown error'));
                                        }
                                      } catch (error) {
                                        console.error('Error reloading shared links:', error);
                                        toast.error('Error reloading: ' + error.message);
                                      }
                                    }}
                                    title="Reload shared links from database"
                                  >
                                    üîÑ
                                  </button>
                                </div>
                              </div>
                              
                              <div className="text-sm text-base-content/70">
                                <p>‚Ä¢ Create shareable links for any file using the üîó button in the Files tab</p>
                                <p>‚Ä¢ Links can be password protected and have expiration dates</p>
                                <p>‚Ä¢ Monitor download counts and manage link access</p>
                              </div>
                              
                              <div className="stats shadow bg-base-200 border border-base-300">
                                <div className="stat">
                                  <div className="stat-title">Link Security</div>
                                  <div className="stat-value text-lg text-success">üîí Enabled</div>
                                  <div className="stat-desc text-success">Password & expiry protection</div>
                                </div>
                              </div>
                            </div>
                          </div>
                        </div>

                        {/* System Information */}
                        <div className="card bg-gradient-to-br from-info/10 to-primary/10 border border-info/20 lg:col-span-2">
                          <div className="card-body">
                            <h3 className="card-title text-info">‚öôÔ∏è System Information</h3>
                            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                              <div className="stat">
                                <div className="stat-title">Frontend</div>
                                <div className="stat-value text-success text-lg">React 18</div>
                                <div className="stat-desc text-success">Modern UI</div>
                              </div>
                              <div className="stat">
                                <div className="stat-title">Backend</div>
                                <div className="stat-value text-primary text-lg">Node.js</div>
                                <div className="stat-desc text-primary">Express Server</div>
                              </div>
                              <div className="stat">
                                <div className="stat-title">Storage</div>
                                <div className="stat-value text-secondary text-lg">IPFS</div>
                                <div className="stat-desc text-secondary">Decentralized</div>
                              </div>
                            </div>
                            <p className="text-sm opacity-80 mt-4">
                              üéØ Decentralized relay system with file storage and IPFS integration. 
                              Built for performance, security, and scalability.
                            </p>
                          </div>
                        </div>
                      </div>
                    </div>
                  ) : (
                    <div className="space-y-6">
                      <div className="alert alert-warning">
                        <div>
                          <h3 className="font-bold">‚ö†Ô∏è Unknown Tab</h3>
                          <div className="text-sm">
                            Current tab "{activeTab}" not recognized. 
                            Available tabs: files, upload, settings
                          </div>
                        </div>
                      </div>
                      <div className="text-center py-8">
                        <div className="text-6xl mb-4">ü§î</div>
                        <h3 className="text-xl font-bold mb-2">Tab content not found</h3>
                        <p className="text-base-content/70 mb-4">Please select a valid tab from the navigation above.</p>
                        <button 
                          className="btn btn-primary" 
                          onClick={() => setActiveTab("files")}
                        >
                          üìÅ Go to Files
                        </button>
                      </div>
                    </div>
                  )}
                </div>
              </div>
            </main>

            {/* Footer */}
            <footer className="footer footer-center p-6 bg-base-200 text-base-content border-t border-base-300">
              <div>
                <div className="font-bold flex items-center justify-center gap-2">
                  <span>ü•∑ Shogun Relay Dashboard - React Edition</span>
                  <div className="badge badge-success">v2.0</div>
                </div>
                <p className="text-sm opacity-70">
                  ¬© 2024 Shogun Protocol ‚Ä¢ Decentralized Relay Dashboard
                </p>
              </div>
            </footer>
          </div>
        );
      }

      // Error Boundary Component
      class ErrorBoundary extends React.Component {
        constructor(props) {
          super(props);
          this.state = { hasError: false, error: null };
        }

        static getDerivedStateFromError(error) {
          return { hasError: true, error };
        }

        componentDidCatch(error, errorInfo) {
          console.error('üö® Dashboard Error:', error, errorInfo);
        }

        render() {
          if (this.state.hasError) {
            return React.createElement('div', { 
              className: 'min-h-screen bg-base-100 flex items-center justify-center p-4' 
            },
              React.createElement('div', { className: 'card bg-error text-error-content shadow-xl max-w-md' },
                React.createElement('div', { className: 'card-body text-center' },
                  React.createElement('h2', { className: 'card-title justify-center' }, 'üö® Dashboard Error'),
                  React.createElement('p', null, this.state.error?.message || 'Something went wrong with the React dashboard'),
                  React.createElement('div', { className: 'card-actions justify-center mt-4' },
                    React.createElement('button', { 
                      className: 'btn btn-primary',
                      onClick: () => window.location.reload()
                    }, 'üîÑ Reload Dashboard')
                  )
                )
              )
            );
          }
          return this.props.children;
        }
      }

      // Enhanced initialization with better error handling
      function initializeDashboard() {
        console.log('üéØ Initializing Shogun Relay Dashboard...');
        
        const appElement = document.getElementById('app');
        if (!appElement) {
          console.error('‚ùå App container not found');
          return;
        }

        // Check for required dependencies
        const dependencies = {
          React: typeof React !== 'undefined',
          ReactDOM: typeof ReactDOM !== 'undefined',
          createRoot: typeof ReactDOM.createRoot !== 'undefined'
        };

        console.log('üì¶ Dependencies check:', dependencies);

        const missingDeps = Object.entries(dependencies)
          .filter(([name, available]) => !available)
          .map(([name]) => name);

        if (missingDeps.length > 0) {
          console.error('‚ùå Missing dependencies:', missingDeps);
          appElement.innerHTML = `
            <div class="fallback-container">
              <div class="fallback-card">
                <h1>‚ùå Loading Error</h1>
                <p>Missing required dependencies: ${missingDeps.join(', ')}</p>
                <button class="fallback-button" onclick="window.location.reload()">üîÑ Retry</button>
              </div>
            </div>
          `;
          return;
        }

        try {
          console.log('üöÄ Creating React root...');
          const root = ReactDOM.createRoot(appElement);
          
          console.log('üé® Rendering dashboard with error boundary...');
          root.render(
            React.createElement(ErrorBoundary, null,
              React.createElement(Dashboard, null)
            )
          );
          
          console.log('‚úÖ Shogun Relay Dashboard loaded successfully!');
          
        } catch (error) {
          console.error('‚ùå Failed to render dashboard:', error);
          appElement.innerHTML = `
            <div class="fallback-container">
              <div class="fallback-card">
                <h1>‚ùå Render Error</h1>
                <p>Failed to initialize React dashboard: ${error.message}</p>
                <button class="fallback-button" onclick="window.location.reload()">üîÑ Reload</button>
              </div>
            </div>
          `;
        }
      }

      // Initialize when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeDashboard);
      } else {
        // DOM is already loaded
        setTimeout(initializeDashboard, 100);
      }
    </script>
  </body>
</html> 