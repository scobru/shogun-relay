<!DOCTYPE html>
<html lang="en" data-theme="dark">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Shogun Relay Dashboard - React</title>
    
    <!-- Tailwind CSS via CDN with DaisyUI -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.12.10/dist/full.min.css" rel="stylesheet" type="text/css" />
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet" />
    
    <!-- React 18 -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
      body { 
        font-family: 'Inter', sans-serif; 
      }
      
      .mono {
        font-family: 'JetBrains Mono', monospace;
      }

      /* Custom scrollbar for a more technical feel */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      
      ::-webkit-scrollbar-track {
        background: hsl(var(--b2));
      }
      
      ::-webkit-scrollbar-thumb {
        background: hsl(var(--b3));
        border-radius: 4px;
      }
      
      ::-webkit-scrollbar-thumb:hover {
        background: hsl(var(--bc));
      }
      
      .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        display: inline-block;
        margin-right: 8px;
      }
      
      .status-online { background-color: hsl(var(--su)); }
      .status-offline { background-color: hsl(var(--er)); }
      .status-warning { background-color: hsl(var(--wa)); }

    </style>
  </head>
  
  <body class="bg-base-100">
    <div id="app">
      <!-- Loading indicator -->
      <div class="h-screen flex items-center justify-center">
        <div class="text-center">
            <h1 class="text-2xl font-bold">ðŸš€ Loading Shogun Relay Dashboard...</h1>
            <p>Initializing React components...</p>
            <span class="loading loading-spinner loading-lg text-primary mt-4"></span>
        </div>
      </div>
    </div>

    <script type="text/babel">
      console.log('ðŸš€ Shogun Relay Dashboard - React Version Starting...');
      console.log('React loaded:', typeof React !== 'undefined');
      console.log('ReactDOM loaded:', typeof ReactDOM !== 'undefined');
      console.log('Current location:', window.location.href);
      
      const { useState, useEffect } = React;

      // Enhanced toast system
      const toast = {
        success: (message) => showToast(message, 'success'),
        error: (message) => showToast(message, 'error'),
        info: (message) => showToast(message, 'info'),
        warning: (message) => showToast(message, 'warning')
      };

      function showToast(message, type = 'info') {
        const toastContainer = document.getElementById('toast-container') || createToastContainer();
        const toastEl = document.createElement('div');
        
        const typeClasses = {
          success: 'alert-success',
          error: 'alert-error', 
          info: 'alert-info',
          warning: 'alert-warning'
        };
        
        toastEl.className = `alert ${typeClasses[type] || 'alert-info'} shadow-lg mb-2`;
        toastEl.innerHTML = `<span>${message}</span>`;
        toastContainer.appendChild(toastEl);
        
        setTimeout(() => {
          if (toastEl.parentNode) {
            toastEl.remove();
          }
        }, 3000);
      }

      function createToastContainer() {
        const container = document.createElement('div');
        container.id = 'toast-container';
        container.className = 'toast toast-end fixed top-4 right-4 z-50';
        container.style.position = 'fixed';
        container.style.top = '1rem';
        container.style.right = '1rem';
        container.style.zIndex = '9999';
        document.body.appendChild(container);
        return container;
      }

      // Main Dashboard Component
      function Dashboard() {
        const [activeTab, setActiveTab] = useState("files");
        const [theme, setTheme] = useState("dark");
        const [fileStats, setFileStats] = useState({ count: 0, totalSize: 0 });
        const [dashboardStats, setDashboardStats] = useState({
          totalFiles: 0,
          todayFiles: 0,
          storage: { used: 0, total: 0, percentage: 0, remainingPercentage: 100 },
          sharedLinks: { total: 0, active: 0, exhausted: 0, expired: 0 }
        });
        const [serverStatus, setServerStatus] = useState({ status: "checking...", port: "8765" });
        const [realFiles, setRealFiles] = useState([]);
        const [relayStatus, setRelayStatus] = useState(null);
        const [ipfsConnectionStatus, setIpfsConnectionStatus] = useState({ status: "checking", message: "Checking IPFS..." });
        const [isLoading, setIsLoading] = useState(true);
        const [dataLoading, setDataLoading] = useState(false);
        const [uploadProgress, setUploadProgress] = useState({});
        const [uploadTarget, setUploadTarget] = useState("auto"); // "local", "ipfs", "auto"
        const [fileFilter, setFileFilter] = useState("all"); // "all", "local", "ipfs"
        const [gunStats, setGunStats] = useState({
          peers: { count: 0, time: 0 },
          nodes: { count: 0 },
          uptime: { time: 0 },
          memory: { heapTotal: 0 },
          dam: { in: { count: 0, done: 0 }, out: { count: 0, done: 0 } },
          cpu: { stack: 0 },
          block: 0
        });

        // File action functions
        const handleFileDownload = async (file) => {
          try {
            console.log('â¬‡ï¸ Downloading file:', file.originalName);
            
            const authToken = window.localStorage.getItem('authToken') ;
            let downloadUrl = null;
            let needsAuth = false;
            
            // Determine download URL based on file type
            if (file.ipfsHash && file.ipfsUrl) {
              // IPFS file - check if it's using local gateway
              if (file.ipfsUrl.includes('127.0.0.1') || file.ipfsUrl.includes('localhost') || file.ipfsUrl.includes('/gateway/ipfs/')) {
                // Local IPFS gateway - needs authentication
                downloadUrl = file.ipfsUrl;
                needsAuth = true;
                toast.info(`ðŸŒ Downloading from local IPFS gateway: ${file.originalName}`);
              } else {
                // External IPFS gateway - no auth needed
                downloadUrl = file.ipfsUrl;
                toast.info(`ðŸŒ Downloading from IPFS: ${file.originalName}`);
              }
            } else if (file.fileUrl) {
              // Local file with direct URL
              downloadUrl = file.fileUrl;
              needsAuth = true;
              toast.info(`ðŸ“ Downloading from local storage: ${file.originalName}`);
            } else if (file.id) {
              // Use file ID to construct download URL
              downloadUrl = `/uploads/${file.id}`;
              needsAuth = true;
              toast.info(`ðŸ“ Downloading: ${file.originalName}`);
            } else {
              throw new Error('No download URL available for this file');
            }
            
            if (needsAuth) {
              // Debug: log the authenticated download
              console.log('ðŸ” Downloading with auth:', downloadUrl);
              
              // For authenticated downloads, use fetch to get the file with auth headers
              const response = await fetch(downloadUrl, {
                headers: {
                  'Authorization': `Bearer ${authToken}`
                }
              });
              
              if (!response.ok) {
                throw new Error(`Download failed: HTTP ${response.status}`);
              }
              
              // Get the file as blob
              const blob = await response.blob();
              
              // Create download link with blob URL
              const blobUrl = URL.createObjectURL(blob);
              const link = document.createElement('a');
              link.href = blobUrl;
              link.download = file.originalName || file.name || 'download';
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
              
              // Clean up blob URL
              setTimeout(() => URL.revokeObjectURL(blobUrl), 1000);
            } else {
              // For public downloads, use direct link
              const link = document.createElement('a');
              link.href = downloadUrl;
              link.download = file.originalName || file.name || 'download';
              link.target = '_blank';
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
            }
            
            toast.success(`âœ… Download started: ${file.originalName}`);
          } catch (error) {
            console.error('âŒ Download error:', error);
            toast.error(`âŒ Download failed: ${error.message}`);
          }
        };

        const handleFileDelete = async (file) => {
          try {
            const fileName = file.originalName || file.name || 'file';
            
            if (!confirm(`Are you sure you want to delete "${fileName}"?`)) {
              return;
            }
            
            console.log('ðŸ—‘ï¸ Deleting file:', fileName, 'ID:', file.id);
            setDataLoading(true);
            
            const authToken = window.localStorage.getItem('authToken') ;
            let deleteUrl = null;
            
            // Determine delete endpoint based on file type
            if (file.storageType === 'ipfs-independent' || (file.independent && file.ipfsHash)) {
              // IPFS independent file - try with file ID first, then hash
              const fileIdentifier = file.id || file.ipfsHash;
              deleteUrl = `/api/ipfs/files/${fileIdentifier}`;
              toast.info(`ðŸŒ Deleting IPFS file: ${fileName}`);
              console.log(`ðŸŒ Using IPFS delete endpoint with identifier: ${fileIdentifier}`);
            } else if (file.id) {
              // Local file or local file with IPFS
              deleteUrl = `/api/files/${file.id}`;
              toast.info(`ðŸ“ Deleting local file: ${fileName}`);
              console.log(`ðŸ“ Using regular delete endpoint with ID: ${file.id}`);
            } else {
              throw new Error('Cannot determine delete endpoint for this file');
            }
            
            let response = await fetch(deleteUrl, {
              method: 'DELETE',
              headers: {
                'Authorization': `Bearer ${authToken}`
              }
            });
            
            // If IPFS delete failed and we have a file ID, try regular delete endpoint as fallback
            if (!response.ok && deleteUrl.includes('/api/ipfs/files/') && file.id) {
              console.log(`ðŸ”„ IPFS delete failed (${response.status}), trying regular delete endpoint for file ID: ${file.id}`);
              toast.info(`ðŸ”„ Trying alternative delete method...`);
              
              const fallbackUrl = `/api/files/${file.id}`;
              response = await fetch(fallbackUrl, {
                method: 'DELETE',
                headers: {
                  'Authorization': `Bearer ${authToken}`
                }
              });
              
              // If both methods failed with 404, the file is already gone
              if (!response.ok && response.status === 404) {
                console.log(`ðŸ”„ Both delete methods returned 404, file was already deleted: ${fileName}`);
                toast.warning(`âš ï¸ File was already deleted: ${fileName}`);
                // Refresh the file list to remove the stale entry
                await loadRealData();
                return; // Exit early since we handled the case
              }
            }
            
            if (response.ok) {
              const result = await response.json();
              if (result.success) {
                toast.success(`âœ… File deleted successfully: ${fileName}`);
                // Refresh the file list
                await loadRealData();
              } else {
                throw new Error(result.error || 'Delete failed');
              }
            } else if (response.status === 404) {
              // File not found - it was probably already deleted
              console.log(`ðŸ”„ File not found (404), removing from display: ${fileName}`);
              toast.warning(`âš ï¸ File was already deleted: ${fileName}`);
              // Refresh the file list to remove the stale entry
              await loadRealData();
            } else {
              const error = await response.json().catch(() => ({ error: `HTTP ${response.status}` }));
              throw new Error(error.error || `HTTP ${response.status}`);
            }
          } catch (error) {
            console.error('âŒ Delete error:', error);
            toast.error(`âŒ Delete failed: ${error.message}`);
          } finally {
            setDataLoading(false);
          }
        };

        const handleFileView = async (file) => {
          try {
            console.log('ðŸ‘ï¸ Viewing file:', file.originalName);
            
            const authToken = window.localStorage.getItem('authToken') ;
            let viewUrl = null;
            
            // Determine view URL based on file type
            if (file.ipfsHash && file.ipfsUrl) {
              // IPFS file - use authenticated URL for local gateway
              if (file.ipfsUrl.includes('127.0.0.1') || file.ipfsUrl.includes('localhost') || file.ipfsUrl.includes('/gateway/ipfs/')) {
                // Local IPFS gateway - add auth token as query parameter
                viewUrl = `${file.ipfsUrl}?token=${authToken}`;
              } else {
                // External IPFS gateway
                viewUrl = file.ipfsUrl;
              }
              toast.info(`ðŸ‘ï¸ Opening IPFS file: ${file.originalName}`);
            } else if (file.fileUrl) {
              // Local file with direct URL
              viewUrl = `${file.fileUrl}?token=${authToken}`;
              toast.info(`ðŸ‘ï¸ Opening local file: ${file.originalName}`);
            } else if (file.id) {
              // Use file ID to construct view URL
              viewUrl = `/uploads/${file.id}?token=${authToken}`;
              toast.info(`ðŸ‘ï¸ Opening file: ${file.originalName}`);
            } else {
              throw new Error('No view URL available for this file');
            }
            
            // Debug: log the URL being opened
            console.log('ðŸ”— Opening URL with auth:', viewUrl);
            
            // Open in new tab
            window.open(viewUrl, '_blank');
            
          } catch (error) {
            console.error('âŒ View error:', error);
            toast.error(`âŒ View failed: ${error.message}`);
          }
        };

        const handleFileInfo = (file) => {
          const fileName = file.originalName || file.name || 'Unknown';
          const fileSize = formatFileSize(file.size || 0);
          const fileType = file.mimetype || file.mimeType || 'Unknown';
          const storageType = file.storageType || 'Unknown';
          const uploadDate = file.timestamp || file.uploadedAt ? 
            new Date(file.timestamp || file.uploadedAt).toLocaleString() : 'Unknown';
          
          let infoMessage = `ðŸ“„ File: ${fileName}\n`;
          infoMessage += `ðŸ“ Size: ${fileSize}\n`;
          infoMessage += `ðŸ·ï¸ Type: ${fileType}\n`;
          infoMessage += `ðŸ’¾ Storage: ${storageType}\n`;
          infoMessage += `ðŸ“… Uploaded: ${uploadDate}`;
          
          if (file.ipfsHash) {
            infoMessage += `\nðŸŒ IPFS Hash: ${file.ipfsHash}`;
            if (file.ipfsUrl) {
              infoMessage += `\nðŸ”— IPFS URL: ${file.ipfsUrl}`;
            }
          }
          
          if (file.id) {
            infoMessage += `\nðŸ†” ID: ${file.id}`;
          }
          
          alert(infoMessage);
          console.log('â„¹ï¸ File info:', file);
        };

        const handleFileShare = async (file) => {
          try {
            console.log('ðŸ”— Creating shareable link for:', file.originalName);
            
            const authToken = window.localStorage.getItem('authToken') ;
            
            // Show modal for share options
            const password = prompt('ðŸ”’ Enter password for the link (optional, leave empty for no password):');
            const expiresIn = prompt('â° Link expires in hours (default: 24, 0 = never expires):', '24');
            const maxDownloads = prompt('ðŸ“¥ Maximum downloads (default: 10):', '10');
            
            const shareData = {
              fileId: file.id,
              password: password || '',
              expiresIn: (parseInt(expiresIn) || 24) * 3600, // Convert hours to seconds
              maxDownloads: parseInt(maxDownloads) || 10,
              description: `Shared file: ${file.originalName || file.name}`
            };
            
            toast.info('ðŸ”— Creating shareable link...');
            
            const response = await fetch('/api/files/create-share-link', {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${authToken}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(shareData)
            });
            
            if (response.ok) {
              const result = await response.json();
              if (result.success) {
                const shareUrl = result.shareData.shareUrl || `${window.location.origin}/api/files/share/${result.shareData.token}`;
                
                // Copy to clipboard
                try {
                  await navigator.clipboard.writeText(shareUrl);
                  toast.success(`ðŸ”— Shareable link created and copied to clipboard!`);
                } catch (clipboardError) {
                  toast.success(`ðŸ”— Shareable link created!`);
                }
                
                // Show the link in a modal-like alert
                const fileType = file.ipfsHash ? 'ðŸŒ IPFS File' : 'ðŸ“ Local File';
                const linkInfo = `ðŸ”— Shareable Link Created!\n\n` +
                  `ðŸ“„ File: ${file.originalName || file.name}\n` +
                  `ðŸ“‚ Type: ${fileType}\n` +
                  `ðŸ”— Link: ${shareUrl}\n` +
                  `ðŸ”’ Password: ${password ? 'Yes' : 'No'}\n` +
                  `â° Expires: ${shareData.expiresIn > 0 ? `${shareData.expiresIn} hours` : 'Never'}\n` +
                  `ðŸ“¥ Max Downloads: ${shareData.maxDownloads}\n\n` +
                  `Link has been copied to clipboard!`;
                
                alert(linkInfo);
                
                console.log('ðŸ”— Share link created:', result);
              } else {
                throw new Error(result.error || 'Failed to create share link');
              }
            } else {
              const error = await response.json();
              throw new Error(error.error || `HTTP ${response.status}`);
            }
          } catch (error) {
            console.error('âŒ Share link creation error:', error);
            toast.error(`âŒ Failed to create share link: ${error.message}`);
          }
        };

        // Function to handle real file upload
                const handleFileUpload = async (event) => {
          const files = Array.from(event.target.files);
          if (files.length === 0) return;
          
          console.log('ðŸ“¤ Starting real file upload:', files.map(f => f.name));
          setDataLoading(true);
          
          // Check IPFS status and user preference
          let ipfsAvailable = false;
          let shouldUseIpfs = false;
          
          try {
            const ipfsStatusResponse = await fetch('/api/ipfs/status', {
              headers: {
                'Authorization': `Bearer ${window.localStorage.getItem('authToken')}`
              }
            });
            
            if (ipfsStatusResponse.ok) {
              const ipfsStatus = await ipfsStatusResponse.json();
              ipfsAvailable = ipfsStatus.success && ipfsStatus.status?.enabled === true;
              console.log(`ðŸŒ IPFS status check: ${ipfsAvailable ? 'Available' : 'Not available'}`);
            }
          } catch (error) {
            console.warn('âš ï¸ Could not check IPFS status:', error);
          }
          
          // Determine upload strategy based on user choice and IPFS availability
          if (uploadTarget === "local") {
            shouldUseIpfs = false;
            toast.info('ðŸ“ Uploading to local storage (user choice)');
          } else if (uploadTarget === "ipfs") {
            if (ipfsAvailable) {
              shouldUseIpfs = true;
              toast.info('ðŸŒ Uploading to IPFS network (user choice)');
            } else {
              toast.error('âŒ IPFS not available! Cannot upload to IPFS. Please choose local storage.');
              setDataLoading(false);
              return;
            }
          } else { // uploadTarget === "auto"
            shouldUseIpfs = ipfsAvailable;
            if (ipfsAvailable) {
              toast.info('ðŸŒ Auto-mode: Uploading to IPFS network');
            } else {
              toast.info('ðŸ“ Auto-mode: IPFS not available, uploading to local storage');
            }
          }
          
          try {
            const uploadPromises = files.map(async (file, index) => {
              const formData = new FormData();
              formData.append('file', file);
              formData.append('customName', file.name);

              // Track individual file progress
              const fileId = `${file.name}_${index}`;
              setUploadProgress(prev => ({ ...prev, [fileId]: 0 }));

              console.log(`ðŸ“¤ Uploading file: ${file.name} (${formatFileSize(file.size)})`);
              
              try {
                let response;
                
                if (shouldUseIpfs) {
                  // Upload to IPFS
                  console.log(`ðŸŒ Uploading ${file.name} to IPFS`);
                  response = await fetch('/api/ipfs/upload', {
                    method: 'POST',
                    headers: {
                      'Authorization': `Bearer ${window.localStorage.getItem('authToken') }`
                    },
                    body: formData
                  });
                } else {
                  // Upload to local storage
                  console.log(`ðŸ“ Uploading ${file.name} to local storage`);
                  response = await fetch('/api/files/upload', {
                    method: 'POST',
                    headers: {
                      'Authorization': `Bearer ${window.localStorage.getItem('authToken') }`
                    },
                    body: formData
                  });
                }

                if (response.ok) {
                  const result = await response.json();
                  console.log(`âœ… File uploaded successfully:`, result);
                  
                  setUploadProgress(prev => ({ ...prev, [fileId]: 100 }));
                  
                  // Show appropriate success message based on upload type
                  if (result.ipfsHash) {
                    toast.success(`âœ… ${file.name} uploaded to IPFS!`);
                  } else if (result.fileUrl || result.path) {
                    toast.success(`âœ… ${file.name} uploaded to local storage!`);
                  } else {
                    toast.success(`âœ… ${file.name} uploaded successfully!`);
                  }
                  
                  // Store uploaded file info in browser storage as fallback
                  if (result.ipfsHash) {
                    try {
                      const recentUploads = JSON.parse(localStorage.getItem('recent_ipfs_uploads') || '[]');
                      const uploadInfo = {
                        ipfsHash: result.ipfsHash,
                        originalName: file.name,
                        name: file.name,
                        size: file.size,
                        mimetype: file.type,
                        ipfsUrl: result.ipfsUrl,
                        timestamp: Date.now(),
                        uploadedAt: Date.now()
                      };
                      
                      // Add to recent uploads (keep last 50)
                      recentUploads.unshift(uploadInfo);
                      const limitedUploads = recentUploads.slice(0, 50);
                      localStorage.setItem('recent_ipfs_uploads', JSON.stringify(limitedUploads));
                      
                      console.log(`ðŸ’¾ Saved upload info to browser storage:`, uploadInfo);
                    } catch (storageError) {
                      console.warn('âš ï¸ Failed to save upload to browser storage:', storageError);
                    }
                  }
                  
                  return result;
                } else {
                  const error = await response.json();
                  console.error(`âŒ Upload failed for ${file.name}:`, error);
                  toast.error(`âŒ Failed to upload ${file.name}: ${error.message || 'Unknown error'}`);
                  throw new Error(error.message || 'Upload failed');
                }
              } catch (fileError) {
                console.error(`âŒ Error uploading ${file.name}:`, fileError);
                toast.error(`âŒ Error uploading ${file.name}: ${fileError.message}`);
                setUploadProgress(prev => ({ ...prev, [fileId]: -1 })); // Mark as failed
                throw fileError;
              }
            });

            // Wait for all uploads to complete
            const results = await Promise.allSettled(uploadPromises);
            
            const successful = results.filter(r => r.status === 'fulfilled').length;
            const failed = results.filter(r => r.status === 'rejected').length;
            
            if (successful > 0) {
              toast.success(`ðŸŽ‰ ${successful} file(s) uploaded successfully!`);
              // Refresh the files list to show new uploads
              await loadRealData();
            }
            
            if (failed > 0) {
              toast.warning(`âš ï¸ ${failed} file(s) failed to upload`);
            }

            // Clear upload progress after a delay
            setTimeout(() => {
              setUploadProgress({});
            }, 3000);

          } catch (error) {
            console.error('âŒ Upload process error:', error);
            toast.error('âŒ Upload failed: ' + error.message);
          } finally {
            setDataLoading(false);
            // Clear the file input
            event.target.value = '';
          }
        };

        // Drag & Drop handlers
        const handleDrop = (event) => {
          event.preventDefault();
          event.stopPropagation();
          
          const files = Array.from(event.dataTransfer.files);
          if (files.length > 0) {
            console.log('ðŸ“ Files dropped:', files.map(f => f.name));
            // Create an event object to handle the file upload
            const uploadEvent = { target: { files: files, value: '' } };
            handleFileUpload(uploadEvent);
          }
        };

        const handleDragOver = (event) => {
          event.preventDefault();
          event.stopPropagation();
        };

        const handleDragEnter = (event) => {
          event.preventDefault();
          event.stopPropagation();
        };

        const handleDragLeave = (event) => {
          event.preventDefault();
          event.stopPropagation();
        };

        // Function to validate file existence and remove stale entries
        const validateFileExistence = async (files, authToken) => {
          if (!files || files.length === 0) return files;
          
          console.log(`ðŸ” Validating existence of ${files.length} files...`);
          const validFiles = [];
          let removedCount = 0;
          
          // Only validate a sample of files to avoid overwhelming the server
          const maxValidationChecks = 10;
          const filesToCheck = files.slice(0, maxValidationChecks);
          const remainingFiles = files.slice(maxValidationChecks);
          
          for (const file of filesToCheck) {
            try {
              // Quick check if file exists by trying to get its info
              const checkUrl = file.storageType === 'ipfs-independent' 
                ? `/api/ipfs/files/${file.id || file.ipfsHash}`
                : `/api/files/${file.id}`;
              
              const response = await fetch(checkUrl, {
                method: 'HEAD', // Use HEAD to avoid downloading file content
                headers: { 'Authorization': `Bearer ${authToken}` }
              });
              
              if (response.ok || response.status === 405) { // 405 = Method Not Allowed (HEAD not supported, but file exists)
                validFiles.push(file);
              } else if (response.status === 404) {
                console.log(`ðŸ—‘ï¸ Removing stale file entry: ${file.originalName || file.name} (${file.id})`);
                removedCount++;
              } else {
                // For other errors, keep the file (might be temporary server issue)
                validFiles.push(file);
              }
            } catch (error) {
              // On network errors, keep the file
              validFiles.push(file);
            }
          }
          
          // Add remaining files without validation to avoid performance issues
          validFiles.push(...remainingFiles);
          
          if (removedCount > 0) {
            console.log(`ðŸ§¹ Removed ${removedCount} stale file entries`);
            toast.info(`ðŸ§¹ Cleaned up ${removedCount} stale file entries`);
          }
          
          return validFiles;
        };

        // Function to load Gun statistics
        const loadGunStats = async () => {
          try {
            console.log('ðŸ“Š Loading Gun statistics...');
            const response = await fetch('/gun/stats.radata', {
              method: 'GET',
              mode: 'cors'
            });
            
            if (response.ok) {
              const data = await response.json();
              console.log('ðŸ“Š Gun stats loaded:', data);
              
              setGunStats({
                peers: {
                  count: data.peers?.count || 0,
                  time: data.peers?.time || 0
                },
                nodes: {
                  count: data.node?.count || 0
                },
                uptime: {
                  time: data.up?.time || 0
                },
                memory: {
                  heapTotal: data.memory?.heapTotal || 0
                },
                dam: {
                  in: {
                    count: data.dam?.in?.count || 0,
                    done: data.dam?.in?.done || 0
                  },
                  out: {
                    count: data.dam?.out?.count || 0,
                    done: data.dam?.out?.done || 0
                  }
                },
                cpu: {
                  stack: data.cpu?.stack || 0
                },
                block: data.block || 0
              });
            } else {
              console.warn('âš ï¸ Gun stats endpoint not available');
            }
          } catch (error) {
            console.warn('âš ï¸ Error loading Gun stats:', error);
          }
        };

        // Function to load combined files (local + IPFS independent)
        const loadRealData = async () => {
          console.log('ðŸ”„ Loading combined data from APIs (local + IPFS)...');
          setDataLoading(true);
          
          try {
            const authToken = window.localStorage.getItem('authToken') ;
            
            // Load local files and IPFS independent files in parallel with better error handling
            const [localFilesResponse, ipfsFilesResponse] = await Promise.allSettled([
              fetch('/api/files/all', {
                headers: { 'Authorization': `Bearer ${authToken}` }
              }),
              fetch('/api/ipfs/files', {
                headers: { 'Authorization': `Bearer ${authToken}` }
              })
            ]);
            
            // Process local files
            let localFiles = [];
            if (localFilesResponse.status === 'fulfilled' && localFilesResponse.value.ok) {
              try {
                const localData = await localFilesResponse.value.json();
                console.log('ðŸ“ Local files loaded:', localData);
                if (localData.success && localData.files) {
                  localFiles = localData.files;
                }
              } catch (parseError) {
                console.warn('âš ï¸ Error parsing local files response:', parseError);
              }
            } else {
              console.warn('âš ï¸ Local files API not available:', localFilesResponse.status === 'fulfilled' ? localFilesResponse.value.status : 'fetch failed');
            }
            
            // Process IPFS independent files with enhanced error handling
            let ipfsFiles = [];
            if (ipfsFilesResponse.status === 'fulfilled' && ipfsFilesResponse.value.ok) {
              try {
                const ipfsData = await ipfsFilesResponse.value.json();
                console.log('ðŸŒ IPFS independent files loaded:', ipfsData);
                if (ipfsData.success && ipfsData.files) {
                  ipfsFiles = ipfsData.files;
                }
              } catch (parseError) {
                console.warn('âš ï¸ Error parsing IPFS files response:', parseError);
              }
            } else {
              const reason = ipfsFilesResponse.status === 'fulfilled' 
                ? `HTTP ${ipfsFilesResponse.value.status}` 
                : 'fetch failed - endpoint may not exist';
              console.warn('âš ï¸ IPFS files API not available:', reason);
              
              // This is expected if the server doesn't have the /api/ipfs/files endpoint
              if (ipfsFilesResponse.status === 'rejected' || 
                  (ipfsFilesResponse.status === 'fulfilled' && ipfsFilesResponse.value.status === 404)) {
                console.info('â„¹ï¸ IPFS independent files endpoint not implemented - this is normal for some servers');
              }
            }
            
            // If IPFS endpoint failed, try to recover recently uploaded files from browser storage
            if (ipfsFiles.length === 0) {
              try {
                const recentUploads = JSON.parse(localStorage.getItem('recent_ipfs_uploads') || '[]');
                const recentValidUploads = recentUploads.filter(upload => 
                  upload.ipfsHash && 
                  upload.timestamp && 
                  (Date.now() - upload.timestamp < 24 * 60 * 60 * 1000) // Last 24 hours
                );
                
                if (recentValidUploads.length > 0) {
                  console.log(`ðŸ”„ Recovered ${recentValidUploads.length} recent IPFS uploads from browser storage`);
                  ipfsFiles = recentValidUploads.map(upload => ({
                    id: upload.ipfsHash,
                    originalName: upload.originalName || upload.name,
                    name: upload.originalName || upload.name,
                    size: upload.size || 0,
                    mimetype: upload.mimetype || 'application/octet-stream',
                    ipfsHash: upload.ipfsHash,
                    ipfsUrl: upload.ipfsUrl,
                    timestamp: upload.timestamp,
                    uploadedAt: upload.timestamp,
                    storageType: 'ipfs-independent',
                    source: 'ipfs-recovered'
                  }));
                  
                  toast.info(`ðŸ”„ Recovered ${ipfsFiles.length} recent uploads from cache`);
                }
              } catch (storageError) {
                console.warn('âš ï¸ Error reading recent uploads from storage:', storageError);
              }
            }
            
            // Combine files from different sources
            const seenIds = new Set();
            const combinedFiles = [];
            
            // Process local files with proper storageType assignment
            localFiles.forEach(file => {
              if (!file || !file.id || seenIds.has(file.id)) {
                return;
              }
              
              // Determine correct storage type for local files
              let storageType = 'local-only';
              if (file.ipfsHash) {
                // Local file that has been uploaded to IPFS
                storageType = 'local-with-ipfs';
              }
              
              const processedFile = {
                ...file,
                storageType,
                source: 'local',
                // Ensure consistent naming
                originalName: file.originalName || file.name,
                mimetype: file.mimetype || file.mimeType
              };
              
              combinedFiles.push(processedFile);
              seenIds.add(file.id);
            });
            
            // Process IPFS independent files
            ipfsFiles.forEach(file => {
              if (!file || !file.id || seenIds.has(file.id)) {
                return;
              }
              
              const processedFile = {
                ...file,
                storageType: 'ipfs-independent',
                source: 'ipfs',
                // Ensure consistent properties
                originalName: file.originalName || file.name,
                mimetype: file.mimeType || file.mimetype,
                // Mark as independent for clarity
                independent: true,
                uploadType: file.uploadType || 'ipfs-direct'
              };
              
              combinedFiles.push(processedFile);
              seenIds.add(file.id);
            });
            
            // Sort files by timestamp (newest first)
            combinedFiles.sort((a, b) => {
              const aTime = parseInt(a.timestamp || a.uploadedAt || 0);
              const bTime = parseInt(b.timestamp || b.uploadedAt || 0);
              return bTime - aTime;
            });
            
            console.log(`ðŸ”„ Combined files result:`);
            console.log(`- Local files: ${localFiles.length}`);
            console.log(`- IPFS files: ${ipfsFiles.length}`);
            console.log(`- Combined total: ${combinedFiles.length}`);
            
            // Validate files and remove any that no longer exist (optional cleanup)
            const validatedFiles = await validateFileExistence(combinedFiles, authToken);
            
            // Update state with validated files
            setRealFiles(validatedFiles);
            
            // Calculate real stats
            const totalSize = validatedFiles.reduce((sum, file) => sum + (file.size || 0), 0);
            setFileStats({
              count: validatedFiles.length,
              totalSize: totalSize
            });
            
            // Load dashboard statistics
            try {
              const statsResponse = await fetch('/api/files/stats', {
                headers: { 'Authorization': `Bearer ${authToken}` }
              });
              
              if (statsResponse.ok) {
                const statsData = await statsResponse.json();
                if (statsData.success && statsData.stats) {
                  setDashboardStats(statsData.stats);
                  console.log('ðŸ“Š Dashboard stats loaded:', statsData.stats);
                }
              }
            } catch (statsError) {
              console.warn('âš ï¸ Failed to load dashboard stats:', statsError);
            }
            
            // Log file categorization for debugging
            const typeGroups = combinedFiles.reduce((acc, f) => {
              acc[f.storageType] = (acc[f.storageType] || 0) + 1;
              return acc;
            }, {});
            console.log('ðŸ“Š File breakdown by storage type:', typeGroups);
            
            // Show appropriate success message
            if (combinedFiles.length > 0) {
              toast.success(`ðŸ“ Loaded ${combinedFiles.length} files (${localFiles.length} local + ${ipfsFiles.length} IPFS)`);
            } else if (localFiles.length === 0 && ipfsFiles.length === 0) {
              // Check if we just uploaded a file but it's not showing up
              const hasRecentUpload = Object.keys(uploadProgress).length > 0 || 
                                     localStorage.getItem('recent_ipfs_uploads') !== null;
              
              if (hasRecentUpload) {
                toast.warning('ðŸ“ Files uploaded but not visible - server may need IPFS files endpoint');
                console.warn('ðŸ” Files were uploaded successfully but are not appearing in the file list. This usually means:');
                console.warn('1. The /api/ipfs/files endpoint is not implemented on this server');
                console.warn('2. Files are stored but not indexed properly');
                console.warn('3. There may be a delay in file processing');
              } else {
                toast.info('ðŸ“‚ No files found - try uploading some files!');
              }
            }
            
            // Load relay status
            try {
              const statusResponse = await fetch('/api/relay/status', {
                headers: {
                  'Authorization': `Bearer ${authToken}`,
                  'Content-Type': 'application/json',
                  token: authToken
                }
              });
              
              if (statusResponse.ok) {
                const statusData = await statusResponse.json();
                console.log('ðŸ”Œ Relay status loaded:', statusData);
                setRelayStatus(statusData);
                setServerStatus({ 
                  status: statusData.success ? "online" : "offline", 
                  port: "8765" 
                });
              } else if (statusResponse.status === 503) {
                // Handle 503 when onchain membership is disabled - this is expected
                const errorData = await statusResponse.json();
                console.log('âš ï¸ Relay services not available (onchain membership disabled):', errorData);
                setRelayStatus({
                  success: false,
                  message: 'Relay services disabled',
                  config: errorData.data?.config || { enabled: false }
                });
                setServerStatus({ 
                  status: "local-mode", 
                  port: "8765",
                  message: "Running in local mode (onchain features disabled)"
                });
              } else {
                console.warn('âš ï¸ Relay status API returned error:', statusResponse.status);
                setServerStatus({ status: "error", port: "8765" });
              }
            } catch (error) {
              console.warn('âš ï¸ Relay status API not available:', error);
              setServerStatus({ status: "offline", port: "8765" });
            }
            
            // Load IPFS status separately
            try {
              const ipfsStatusResponse = await fetch('/api/ipfs/status', {
                headers: {
                  'Authorization': `Bearer ${authToken}`
                }
              });
              
              if (ipfsStatusResponse.ok) {
                const ipfsData = await ipfsStatusResponse.json();
                console.log('ðŸŒ IPFS status loaded:', ipfsData);
                
                if (ipfsData.success && ipfsData.status?.enabled) {
                  setIpfsConnectionStatus({ 
                    status: 'connected', 
                    message: `${ipfsData.status.service || 'IPFS'} Active`,
                    service: ipfsData.status.service,
                    gateway: ipfsData.status.gateway
                  });
                } else {
                  setIpfsConnectionStatus({ 
                    status: 'disabled', 
                    message: 'IPFS Disabled',
                    service: ipfsData.status?.service || 'Unknown'
                  });
                }
              } else {
                console.warn('âš ï¸ IPFS status API returned error:', ipfsStatusResponse.status);
                setIpfsConnectionStatus({ 
                  status: 'error', 
                  message: 'IPFS API Error' 
                });
              }
            } catch (error) {
              console.warn('âš ï¸ IPFS status API not available:', error);
              setIpfsConnectionStatus({ 
                status: 'error', 
                message: 'IPFS Unavailable' 
              });
            }
            
          } catch (error) {
            console.error('âŒ Error loading combined data:', error);
            toast.error('Failed to load files: ' + error.message);
            setRealFiles([]);
            setFileStats({ count: 0, totalSize: 0 });
          } finally {
            setDataLoading(false);
          }
        };

        useEffect(() => {
          console.log('ðŸ” Dashboard component mounted. Initial activeTab:', activeTab);
          
          // Check for auth token, redirect to login if not found
          const authToken = window.localStorage.getItem('authToken');
          if (!authToken) {
            console.log('âŒ No auth token found, redirecting to login.');
            toast.error('Authentication required. Redirecting to login...');
            window.location.href = '/login';
            return;
          }
          
          // Initialize dashboard and load real data
          const initializeDashboard = async () => {
            setIsLoading(false);
            toast.success('ðŸŽ‰ Dashboard loaded successfully!');
            console.log('ðŸ” Loading complete. Current activeTab:', activeTab);
            
            // Load real data from APIs
            await loadRealData();
            await loadGunStats();
          };
          
          // Small delay for UI then load real data
          setTimeout(initializeDashboard, 500);
          
          // Set up periodic Gun stats updates
          const gunStatsInterval = setInterval(loadGunStats, 5000); // Every 5 seconds
          
          return () => {
            clearInterval(gunStatsInterval);
          };
        }, []);
        
        useEffect(() => {
          console.log('ðŸ” ActiveTab changed to:', activeTab);
        }, [activeTab]);

        const toggleTheme = () => {
          const newTheme = theme === "dark" ? "light" : "dark";
          setTheme(newTheme);
          document.documentElement.setAttribute("data-theme", newTheme);
          toast.info(`Theme switched to ${newTheme} mode`);
        };

        const formatFileSize = (bytes) => {
          if (bytes === 0) return "0 Bytes";
          const k = 1024;
          const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
          const i = Math.floor(Math.log(bytes) / Math.log(k));
          return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
        };

        if (isLoading) {
          return (
            <div className="min-h-screen bg-base-100 flex items-center justify-center">
              <div className="text-center">
                <div className="loading loading-spinner loading-lg text-primary mb-4"></div>
                <h2 className="text-2xl font-bold">ðŸš€ Initializing Dashboard</h2>
                <p className="text-base-content/70">Loading Shogun Relay Dashboard...</p>
              </div>
            </div>
          );
        }

        return (
          <div className="min-h-screen bg-base-200">
            {/* Header */}
            <header className="navbar bg-base-300 shadow px-4 lg:px-6 border-b border-base-100">
              <div className="navbar-start">
                <h1 className="btn btn-ghost text-xl font-bold">ðŸ¥· Shogun Relay</h1>
              </div>
              <div className="navbar-center hidden lg:flex">
                <div className="text-lg font-semibold text-base-content/80">Relay Dashboard</div>
              </div>
              <div className="navbar-end">
                <button onClick={toggleTheme} className="btn btn-ghost btn-circle">
                  {theme === "dark" ? "ðŸŒž" : "ðŸŒ™"}
                </button>
              </div>
            </header>

            <main className="container mx-auto px-4 py-6 max-w-7xl">
              {/* Header */}
              <div className="card bg-base-200 border border-base-300 p-6 mb-8">
                  <div className="flex items-center gap-4">
                    <div className="text-4xl">ðŸ¥·</div>
                    <div>
                      <h1 className="text-3xl font-bold">
                        Shogun Relay Dashboard
                      </h1>
                      <p className="text-base-content/70">Decentralized file storage and relay management</p>
                    </div>
                  </div>
              </div>
              
              {/* Local Mode Info Alert */}
              {serverStatus.status === "local-mode" && (
                <div role="alert" className="alert alert-info mb-6">
                  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" className="stroke-current shrink-0 w-6 h-6"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                  <div>
                    <h4 className="font-bold">Running in Local Mode</h4>
                    <div className="text-xs">The relay is operating in local-only mode with onchain features disabled.</div>
                  </div>
                </div>
              )}

              {/* Stats Cards */}
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
                <div className="stat card bg-base-200 border border-base-300">
                  <div className="stat-figure text-primary text-3xl">ðŸ“</div>
                  <div className="stat-title">Total Files</div>
                  <div className="stat-value text-primary">
                    {dataLoading ? <span className="loading loading-spinner loading-sm"></span> : fileStats.count}
                  </div>
                  <div className="stat-desc">
                    <span className="status-dot status-online"></span>
                    Real files from relay
                  </div>
                </div>
                
                <div className="stat card bg-base-200 border border-base-300">
                  <div className="stat-figure text-secondary text-3xl">ðŸ’¾</div>
                  <div className="stat-title">Storage Used</div>
                  <div className="stat-value text-secondary">
                     {dataLoading ? <span className="loading loading-spinner loading-sm"></span> : formatFileSize(fileStats.totalSize)}
                  </div>
                  <div className="stat-desc">
                    <span className="status-dot status-online"></span>
                    Actual storage usage
                  </div>
                </div>
                
                <div className="stat card bg-base-200 border border-base-300">
                  <div className="stat-figure text-accent text-3xl">ðŸ–¥ï¸</div>
                  <div className="stat-title">Server Status</div>
                  <div className="stat-value">
                     <span className={`badge badge-lg font-bold ${
                        serverStatus.status === "online" ? "badge-success" : 
                        serverStatus.status === "local-mode" ? "badge-warning" :
                        serverStatus.status === "checking..." ? "badge-info" : 
                        "badge-error"
                      }`}>
                        {serverStatus.status === "local-mode" ? "Local Mode" : serverStatus.status}
                      </span>
                  </div>
                  <div className="stat-desc">
                    <span className={`status-dot ${
                      serverStatus.status === "online" ? "status-online" :
                      serverStatus.status === "local-mode" ? "status-warning" :
                      "status-offline"
                    }`}></span>
                    {serverStatus.message ? serverStatus.message : `Port: ${serverStatus.port}`}
                  </div>
                </div>
                
                <div className="stat card bg-base-200 border border-base-300">
                  <div className="stat-figure text-info text-3xl">ðŸŒ</div>
                  <div className="stat-title">IPFS Status</div>
                  <div className="stat-value">
                    {dataLoading ? <span className="loading loading-spinner loading-sm"></span> : (
                      <span className={`badge badge-lg font-bold ${
                        ipfsConnectionStatus?.status === 'connected' ? 'badge-success' :
                        ipfsConnectionStatus?.status === 'disabled' ? 'badge-warning' :
                        ipfsConnectionStatus?.status === 'error' ? 'badge-error' :
                        'badge-info'
                      }`}>
                        {ipfsConnectionStatus?.status === 'connected' ? 'Active' :
                         ipfsConnectionStatus?.status === 'disabled' ? 'Disabled' :
                         ipfsConnectionStatus?.status === 'error' ? 'Error' : 'Checking...'}
                      </span>
                    )}
                  </div>
                  <div className="stat-desc">
                    <span className={`status-dot ${
                      ipfsConnectionStatus?.status === 'connected' ? 'status-online' :
                      ipfsConnectionStatus?.status === 'disabled' ? 'status-warning' :
                      'status-offline'
                    }`}></span>
                    {ipfsConnectionStatus?.message || "IPFS service status"}
                  </div>
                </div>
              </div>

              {/* Gun.js Network Statistics */}
              <div className="card bg-base-200 border border-base-300 p-6 mb-8">
                  <div className="flex items-center gap-4 mb-4">
                    <div className="text-3xl">ðŸ”—</div>
                    <h2 className="text-xl font-bold">
                        Gun.js Network Statistics
                    </h2>
                  </div>
                  
                  <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4 text-center">
                    <div className="stat">
                      <div className="stat-title text-sm">Peers</div>
                      <div className="stat-value text-lg mono">{gunStats.peers.count}</div>
                    </div>
                    <div className="stat">
                      <div className="stat-title text-sm">Peer Time</div>
                      <div className="stat-value text-lg mono">{Math.round(gunStats.peers.time / 1000 / 60)}m</div>
                    </div>
                    <div className="stat">
                      <div className="stat-title text-sm">Nodes</div>
                      <div className="stat-value text-lg mono">{gunStats.nodes.count}</div>
                    </div>
                    <div className="stat">
                      <div className="stat-title text-sm">Uptime</div>
                      <div className="stat-value text-lg mono">{(gunStats.uptime.time / 60 / 60).toFixed(1)}h</div>
                    </div>
                    <div className="stat">
                      <div className="stat-title text-sm">Memory</div>
                      <div className="stat-value text-lg mono">{(gunStats.memory.heapTotal / 1024 / 1024).toFixed(0)}MB</div>
                    </div>
                    <div className="stat">
                      <div className="stat-title text-sm">Block</div>
                      <div className="stat-value text-lg mono">{gunStats.block.toFixed(1)}s</div>
                    </div>
                  </div>

                  <div className="divider"></div>

                  <h3 className="text-lg font-bold mb-4 flex items-center gap-2">
                    <span className="text-2xl">ðŸ“¡</span>
                    DAM Network Activity
                  </h3>
                  <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-center">
                      <div className="stat">
                        <div className="stat-title text-sm">In Count</div>
                        <div className="stat-value text-base mono">{gunStats.dam.in.count}</div>
                      </div>
                      <div className="stat">
                        <div className="stat-title text-sm">In Size</div>
                        <div className="stat-value text-base mono">{(gunStats.dam.in.done / 1024 / 1024).toFixed(1)}MB</div>
                      </div>
                      <div className="stat">
                        <div className="stat-title text-sm">Out Count</div>
                        <div className="stat-value text-base mono">{gunStats.dam.out.count}</div>
                      </div>
                      <div className="stat">
                        <div className="stat-title text-sm">Out Size</div>
                        <div className="stat-value text-base mono">{(gunStats.dam.out.done / 1024 / 1024).toFixed(1)}MB</div>
                      </div>
                  </div>

                  <div className="mt-6 flex gap-3">
                    <button 
                      className="btn btn-outline btn-sm"
                      onClick={loadGunStats}
                    >
                      <span>ðŸ”„</span>
                      <span>Refresh Gun Stats</span>
                    </button>
                  </div>
              </div>

              {/* Main content area */}
              <div className="card bg-base-200 border border-base-300">
                <div className="tabs tabs-bordered px-6 pt-4">
                  <a className={`tab tab-lg tab-bordered ${activeTab === 'files' ? 'tab-active' : ''}`} onClick={() => setActiveTab('files')}>Files</a> 
                  <a className={`tab tab-lg tab-bordered ${activeTab === 'upload' ? 'tab-active' : ''}`} onClick={() => setActiveTab('upload')}>Upload</a> 
                  <a className={`tab tab-lg tab-bordered ${activeTab === 'settings' ? 'tab-active' : ''}`} onClick={() => setActiveTab('settings')}>Settings</a>
                </div>

                <div className="p-6">
                  {/* Tab Content */}
                  {activeTab === "files" ? (
                    <div className="space-y-6">
                      <div className="flex items-center justify-between">
                        <h2 className="text-xl font-bold">ðŸ“ Files Management</h2>
                        <div className="flex gap-3">
                          <button 
                            className={`btn btn-sm btn-outline ${dataLoading ? 'loading' : ''}`} 
                            onClick={loadRealData}
                            disabled={dataLoading}
                          >
                            {dataLoading ? (
                              <span className="loading loading-spinner loading-sm"></span>
                            ) : (
                              <span>ðŸ”„</span>
                            )}
                            <span>{dataLoading ? 'Loading...' : 'Refresh'}</span>
                          </button>
                        </div>
                      </div>
                      
                      {/* File Filter Tabs */}
                      <div className="tabs tabs-boxed">
                        <a className={`tab ${fileFilter === 'all' ? 'tab-active' : ''}`} onClick={() => setFileFilter('all')}>All ({realFiles.length})</a> 
                        <a className={`tab ${fileFilter === 'local' ? 'tab-active' : ''}`} onClick={() => setFileFilter('local')}>Local ({realFiles.filter(f => f.storageType === 'local-only' || f.storageType === 'local-with-ipfs').length})</a> 
                        <a className={`tab ${fileFilter === 'ipfs' ? 'tab-active' : ''}`} onClick={() => setFileFilter('ipfs')}>IPFS ({realFiles.filter(f => f.storageType === 'ipfs-independent' || f.ipfsHash).length})</a>
                      </div>
                      
                      {/* IPFS Warning */}
                      {fileFilter === 'ipfs' && ipfsConnectionStatus.status !== 'connected' && (
                        <div role="alert" className="alert alert-warning">
                          <svg xmlns="http://www.w3.org/2000/svg" className="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" /></svg>
                          <div>
                            <h4 className="font-bold">IPFS Service Unavailable</h4>
                            <div className="text-xs">IPFS files may not be accessible because the IPFS service is currently offline.</div>
                          </div>
                        </div>
                      )}

                      <div className="overflow-x-auto">
                        {dataLoading ? (
                          <div className="text-center py-8">
                            <span className="loading loading-spinner loading-lg text-primary"></span>
                            <p>Loading files...</p>
                          </div>
                        ) : realFiles.filter(file => {
                          if (fileFilter === 'all') return true;
                          if (fileFilter === 'local') return file.storageType === 'local-only' || file.storageType === 'local-with-ipfs';
                          if (fileFilter === 'ipfs') return file.storageType === 'ipfs-independent' || file.ipfsHash;
                          return true;
                        }).length === 0 ? (
                           <div className="text-center py-8">
                            <div className="text-4xl mb-4">ðŸ“‚</div>
                            <h3 className="text-lg font-bold mb-2">No Files Found</h3>
                            <p className="text-base-content/70 mb-4">The relay doesn't have any files yet.</p>
                            <button className="btn btn-primary btn-sm" onClick={() => setActiveTab("upload")}>
                              ðŸ“¤ Upload Files
                            </button>
                          </div>
                        ) : (
                          <table className="table table-compact w-full">
                            <thead>
                              <tr>
                                <th>File</th>
                                <th>Size</th>
                                <th className="hidden md:table-cell">Type</th>
                                <th>Storage</th>
                                <th>Actions</th>
                              </tr>
                            </thead>
                            <tbody>
                              {realFiles.filter(file => {
                                if (fileFilter === 'all') return true;
                                if (fileFilter === 'local') return file.storageType === 'local-only' || file.storageType === 'local-with-ipfs';
                                if (fileFilter === 'ipfs') return file.storageType === 'ipfs-independent' || file.ipfsHash;
                                return true;
                              }).map((file, index) => (
                                  <tr key={file.id || index} className="hover">
                                    <td>
                                      <div className="font-bold truncate max-w-xs">{file.originalName || file.filename || `file_${index}`}</div>
                                      <div className="text-sm opacity-70 mono">{file.id || `file_${index}`}</div>
                                    </td>
                                    <td className="mono">{formatFileSize(file.size || 0)}</td>
                                    <td className="hidden md:table-cell">
                                      <span className="badge badge-ghost badge-sm">{file.mimetype}</span>
                                    </td>
                                    <td>
                                       {file.storageType === 'local-only' && <span className="badge badge-info badge-sm">Local</span>}
                                       {file.storageType === 'local-with-ipfs' && <span className="badge badge-success badge-sm">Local+IPFS</span>}
                                       {file.storageType === 'ipfs-independent' && <span className="badge badge-warning badge-sm">IPFS Only</span>}
                                       {!file.storageType && file.ipfsHash && <span className="badge badge-secondary badge-sm">IPFS</span>}
                                       {!file.storageType && !file.ipfsHash && <span className="badge badge-outline badge-sm">Local</span>}
                                    </td>
                                    <td>
                                      <div className="btn-group">
                                        <button className="btn btn-ghost btn-xs" onClick={() => handleFileView(file)} title="View">ðŸ‘ï¸</button>
                                        <button className="btn btn-ghost btn-xs" onClick={() => handleFileDownload(file)} title="Download">â¬‡ï¸</button>
                                        <button className="btn btn-ghost btn-xs" onClick={() => handleFileInfo(file)} title="Info">â„¹ï¸</button>
                                        <button className="btn btn-ghost btn-xs" onClick={() => handleFileShare(file)} title="Share">ðŸ”—</button>
                                        <button className="btn btn-ghost btn-xs" onClick={() => handleFileDelete(file)} title="Delete">ðŸ—‘ï¸</button>
                                      </div>
                                    </td>
                                  </tr>
                                ))}
                            </tbody>
                          </table>
                        )}
                      </div>
                    </div>

                  ) : activeTab === "upload" ? (
                    <div className="space-y-6">
                      <h2 className="text-xl font-bold">ðŸ“¤ File Upload Zone</h2>
                      
                      {/* Upload Target Selection */}
                      <div className="card bg-base-100 shadow-md border border-base-300">
                        <div className="card-body">
                          <h3 className="card-title text-sm">Upload Destination</h3>
                          <div className="join w-full">
                            <button className={`btn btn-sm join-item flex-grow ${uploadTarget === 'auto' ? 'btn-active' : ''}`} onClick={() => setUploadTarget('auto')}>Auto</button>
                            <button className={`btn btn-sm join-item flex-grow ${uploadTarget === 'ipfs' ? 'btn-active' : ''}`} onClick={() => setUploadTarget('ipfs')}>IPFS</button>
                            <button className={`btn btn-sm join-item flex-grow ${uploadTarget === 'local' ? 'btn-active' : ''}`} onClick={() => setUploadTarget('local')}>Local</button>
                          </div>
                        </div>
                      </div>

                      <div 
                        className="border-2 border-dashed border-base-300 rounded-lg p-12 text-center hover:border-primary transition-all"
                        onDrop={handleDrop}
                        onDragOver={handleDragOver}
                        onDragEnter={handleDragEnter}
                        onDragLeave={handleDragLeave}
                      >
                        <div className="text-6xl mb-4">ðŸ“¤</div>
                        <h3 className="text-xl font-bold mb-2">Drop files here to upload</h3>
                        <p className="text-base-content/70 mb-4">
                          or click to select
                        </p>
                        {dataLoading && <div className="loading loading-spinner text-primary mb-4"></div>}
                        <input 
                          type="file" 
                          multiple 
                          className="file-input file-input-bordered file-input-sm file-input-primary max-w-xs" 
                          onChange={handleFileUpload}
                          disabled={dataLoading}
                        />
                      </div>
                      
                    </div>

                  ) : activeTab === "settings" ? (
                    <div className="space-y-8">
                      <h2 className="text-xl font-bold">âš™ï¸ Dashboard Configuration</h2>
                      
                      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        {/* Appearance Settings */}
                        <div className="card bg-base-100 shadow-md border border-base-300">
                          <div className="card-body">
                            <h3 className="card-title text-base">ðŸŽ¨ Appearance</h3>
                            <div className="form-control">
                              <label className="label cursor-pointer">
                                <span className="label-text">Dark Mode</span> 
                                <input type="checkbox" className="toggle toggle-primary" checked={theme === "dark"} onChange={toggleTheme} />
                              </label>
                            </div>
                          </div>
                        </div>

                        {/* Server Status */}
                        <div className="card bg-base-100 shadow-md border border-base-300">
                          <div className="card-body">
                            <h3 className="card-title text-base">ðŸ–¥ï¸ Server Status</h3>
                            <div className="text-sm">
                              <p>Status: <span className="font-bold">{serverStatus.status}</span></p>
                              <p>Port: <span className="font-mono">{serverStatus.port}</span></p>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  ) : null }
                </div>
              </div>
            </main>

            {/* Footer */}
            <footer className="footer footer-center p-4 bg-base-300 text-base-content mt-8 border-t border-base-100">
              <div>
                <p className="text-sm">
                  ðŸ¥· Shogun Relay Dashboard v2.0 Â© 2024
                </p>
              </div>
            </footer>
          </div>
        );
      }

      // Error Boundary Component
      class ErrorBoundary extends React.Component {
        constructor(props) {
          super(props);
          this.state = { hasError: false, error: null };
        }

        static getDerivedStateFromError(error) {
          return { hasError: true, error };
        }

        componentDidCatch(error, errorInfo) {
          console.error('ðŸš¨ Dashboard Error:', error, errorInfo);
        }

        render() {
          if (this.state.hasError) {
            return React.createElement('div', { 
              className: 'min-h-screen bg-base-100 flex items-center justify-center p-4' 
            },
              React.createElement('div', { className: 'card bg-error text-error-content shadow-xl max-w-md' },
                React.createElement('div', { className: 'card-body text-center' },
                  React.createElement('h2', { className: 'card-title justify-center' }, 'ðŸš¨ Dashboard Error'),
                  React.createElement('p', null, this.state.error?.message || 'Something went wrong with the React dashboard'),
                  React.createElement('div', { className: 'card-actions justify-center mt-4' },
                    React.createElement('button', { 
                      className: 'btn btn-primary',
                      onClick: () => window.location.reload()
                    }, 'ðŸ”„ Reload Dashboard')
                  )
                )
              )
            );
          }
          return this.props.children;
        }
      }

      // Enhanced initialization with better error handling
      function initializeDashboard() {
        console.log('ðŸŽ¯ Initializing Shogun Relay Dashboard...');
        
        const appElement = document.getElementById('app');
        if (!appElement) {
          console.error('âŒ App container not found');
          return;
        }

        // Check for required dependencies
        const dependencies = {
          React: typeof React !== 'undefined',
          ReactDOM: typeof ReactDOM !== 'undefined',
          createRoot: typeof ReactDOM.createRoot !== 'undefined'
        };

        console.log('ðŸ“¦ Dependencies check:', dependencies);

        const missingDeps = Object.entries(dependencies)
          .filter(([name, available]) => !available)
          .map(([name]) => name);

        if (missingDeps.length > 0) {
          console.error('âŒ Missing dependencies:', missingDeps);
          appElement.innerHTML = `
            <div class="fallback-container">
              <div class="fallback-card">
                <h1>âŒ Loading Error</h1>
                <p>Missing required dependencies: ${missingDeps.join(', ')}</p>
                <button class="fallback-button" onclick="window.location.reload()">ðŸ”„ Retry</button>
              </div>
            </div>
          `;
          return;
        }

        try {
          console.log('ðŸš€ Creating React root...');
          const root = ReactDOM.createRoot(appElement);
          
          console.log('ðŸŽ¨ Rendering dashboard with error boundary...');
          root.render(
            React.createElement(ErrorBoundary, null,
              React.createElement(Dashboard, null)
            )
          );
          
          console.log('âœ… Shogun Relay Dashboard loaded successfully!');
          
        } catch (error) {
          console.error('âŒ Failed to render dashboard:', error);
          appElement.innerHTML = `
            <div class="fallback-container">
              <div class="fallback-card">
                <h1>âŒ Render Error</h1>
                <p>Failed to initialize React dashboard: ${error.message}</p>
                <button class="fallback-button" onclick="window.location.reload()">ðŸ”„ Reload</button>
              </div>
            </div>
          `;
        }
      }

      // Initialize when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeDashboard);
      } else {
        // DOM is already loaded
        setTimeout(initializeDashboard, 100);
      }
    </script>
  </body>
</html> 